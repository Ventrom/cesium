{"version":3,"file":"PolylineVolumeGeometryLibrary-6c9cb4ba.js","sources":["../../../../Source/Core/CornerType.js","../../../../Source/Core/PolylineVolumeGeometryLibrary.js"],"sourcesContent":["/**\n * Style options for corners.\n *\n * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n *\n * @enum {Number}\n */\nvar CornerType = {\n  /**\n   * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner has a smooth edge.\n   * @type {Number}\n   * @constant\n   */\n  ROUNDED: 0,\n\n  /**\n   * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner point is the intersection of adjacent edges.\n   * @type {Number}\n   * @constant\n   */\n  MITERED: 1,\n\n  /**\n   * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner is clipped.\n   * @type {Number}\n   * @constant\n   */\n  BEVELED: 2,\n};\nexport default Object.freeze(CornerType);\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\n\nvar scratch2Array = [new Cartesian3(), new Cartesian3()];\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCartesian7 = new Cartesian3();\nvar scratchCartesian8 = new Cartesian3();\nvar scratchCartesian9 = new Cartesian3();\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nvar PolylineVolumeGeometryLibrary = {};\n\nvar cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  var heights = new Array(positions.length);\n  for (var i = 0; i < positions.length; i++) {\n    var pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  var p0 = points[0];\n  var p1 = points[1];\n  var angleBetween = Cartesian3.angleBetween(p0, p1);\n  var numPoints = Math.ceil(angleBetween / granularity);\n  var heights = new Array(numPoints);\n  var i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nvar nextScratch = new Cartesian3();\nvar prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, start, nextScratch),\n    nextScratch\n  );\n  var prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, end, prevScratch),\n    prevScratch\n  );\n  var angle = Cartesian2.angleBetween(next, prev);\n\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nvar negativeX = new Cartesian3(-1, 0, 0);\nvar transform = new Matrix4();\nvar translation = new Matrix4();\nvar rotationZ = new Matrix3();\nvar scaleMatrix = Matrix3.IDENTITY.clone();\nvar westScratch = new Cartesian3();\nvar finalPosScratch = new Cartesian4();\nvar heightCartesian = new Cartesian3();\nfunction addPosition(\n  center,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  height,\n  xScalar,\n  repeat\n) {\n  var west = westScratch;\n  var finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  var angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\n    transform\n  );\n  var scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (var j = 0; j < repeat; j++) {\n    for (var i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(\n        scale,\n        finalPosition,\n        finalPosition\n      );\n      finalPosition = Matrix4.multiplyByPoint(\n        transform,\n        finalPosition,\n        finalPosition\n      );\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nvar centerScratch = new Cartesian3();\nfunction addPositions(\n  centers,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  heights,\n  xScalar\n) {\n  for (var i = 0; i < centers.length; i += 3) {\n    var center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(\n      center,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      heights[i / 3],\n      xScalar,\n      1\n    );\n  }\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  var length = shape2D.length;\n  var shape = new Array(length * 6);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  var point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (var i = 1; i < length; i++) {\n    point = shape2D[i];\n    var x = point.x - xOffset;\n    var z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  var length = shape2D.length;\n  var shape = new Array(length * 3);\n  var index = 0;\n  var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (var i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nvar quaterion = new Quaternion();\nvar startPointScratch = new Cartesian3();\nvar rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  pivot,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n  ellipsoid,\n  finalPositions,\n  shape,\n  height,\n  duplicatePoints\n) {\n  var angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, pivot, scratch1),\n    Cartesian3.subtract(endPoint, pivot, scratch2)\n  );\n  var granularity =\n    cornerType === CornerType.BEVELED\n      ? 0\n      : Math.ceil(angle / CesiumMath.toRadians(5));\n\n  var m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(pivot, scratch1),\n        angle / (granularity + 1),\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\n      rotMatrix\n    );\n  }\n\n  var left;\n  var surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    var repeat = duplicatePoints ? 2 : 1;\n    for (var i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(\n        surfacePoint,\n        left,\n        shape,\n        finalPositions,\n        ellipsoid,\n        height,\n        1,\n        repeat\n      );\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\n  shapePositions\n) {\n  var length = shapePositions.length;\n  var cleanedPositions = [];\n  for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    var v0 = shapePositions[i0];\n    var v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\n  forward,\n  backward,\n  position,\n  ellipsoid\n) {\n  var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  var next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, forward, nextScratch),\n    nextScratch\n  );\n  var prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, backward, prevScratch),\n    prevScratch\n  );\n\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (\n  positions,\n  shape2D,\n  boundingRectangle,\n  geometry,\n  duplicatePoints\n) {\n  var ellipsoid = geometry._ellipsoid;\n  var heights = scaleToSurface(positions, ellipsoid);\n  var granularity = geometry._granularity;\n  var cornerType = geometry._cornerType;\n  var shapeForSides = duplicatePoints\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\n    : convertShapeTo3D(shape2D, boundingRectangle);\n  var shapeForEnds = duplicatePoints\n    ? convertShapeTo3D(shape2D, boundingRectangle)\n    : undefined;\n  var heightOffset = boundingRectangle.height / 2;\n  var width = boundingRectangle.width / 2;\n  var length = positions.length;\n  var finalPositions = [];\n  var ends = duplicatePoints ? [] : undefined;\n\n  var forward = scratchCartesian1;\n  var backward = scratchCartesian2;\n  var cornerDirection = scratchCartesian3;\n  var surfaceNormal = scratchCartesian4;\n  var pivot = scratchCartesian5;\n  var start = scratchCartesian6;\n  var end = scratchCartesian7;\n  var left = scratchCartesian8;\n  var previousPosition = scratchCartesian9;\n\n  var position = positions[0];\n  var nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  var h0 = heights[0];\n  var h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h0 + heightOffset,\n      1,\n      1\n    );\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  var subdividedHeights;\n  var subdividedPositions;\n  for (var i = 1; i < length - 1; i++) {\n    var repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n    cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n    var forwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(forward, surfaceNormal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    var backwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(backward, surfaceNormal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    var doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        surfaceNormal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        surfaceNormal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar =\n        1 /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(\n        previousPosition,\n        left,\n        shapeForSides,\n        finalPositions,\n        ellipsoid,\n        h0 + heightOffset,\n        1,\n        1\n      );\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(\n    scratch2Array,\n    h0 + heightOffset,\n    h1 + heightOffset,\n    granularity\n  );\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  finalPositions = addPositions(\n    subdividedPositions,\n    left,\n    shapeForSides,\n    finalPositions,\n    ellipsoid,\n    subdividedHeights,\n    1\n  );\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h1 + heightOffset,\n      1,\n      1\n    );\n  }\n\n  length = finalPositions.length;\n  var posLength = duplicatePoints ? length + ends.length : length;\n  var combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;\n"],"names":["Object","freeze","ROUNDED","MITERED","BEVELED","scratch2Array","Cartesian3","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","Cartographic","subdivideHeights","points","h0","h1","granularity","i","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","push","heightPerVertex","h","nextScratch","prevScratch","negativeX","transform","Matrix4","translation","rotationZ","Matrix3","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","center","left","shape","finalPositions","ellipsoid","height","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","multiplyByPointAsVector","normalize","start","end","position","tangentPlane","next","prev","angle","EllipsoidTangentPlane","projectPointOntoPlane","add","Cartesian2","x","y","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","length","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","index","xOffset","width","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","CornerType","CesiumMath","toRadians","fromQuaternion","fromAxisAngle","negate","scaleToGeodeticSurface","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","geometry","_ellipsoid","pos","cartesianToCartographic","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","forwardProjection","multiplyByScalar","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","PolylinePipeline","generateArc","posLength","combinedPositions","Float64Array","set"],"mappings":"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"}