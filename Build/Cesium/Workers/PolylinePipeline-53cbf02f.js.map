{"version":3,"file":"PolylinePipeline-53cbf02f.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nvar PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  var distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  var radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)))\n  );\n};\n\nvar cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  var length = positions.length;\n  var heights = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nvar wrapLongitudeInversMatrix = new Matrix4();\nvar wrapLongitudeOrigin = new Cartesian3();\nvar wrapLongitudeXZNormal = new Cartesian3();\nvar wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeYZNormal = new Cartesian3();\nvar wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeIntersection = new Cartesian3();\nvar wrapLongitudeOffset = new Cartesian3();\n\nvar subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  var heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  var i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nvar carto1 = new Cartographic();\nvar carto2 = new Cartographic();\nvar cartesian = new Cartesian3();\nvar scaleFirst = new Cartesian3();\nvar scaleLast = new Cartesian3();\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\nvar ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var start = ellipsoid.cartesianToCartographic(first, carto1);\n  var end = ellipsoid.cartesianToCartographic(last, carto2);\n  var heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  var start = ellipsoid.cartesianToCartographic(p0, carto1);\n  var end = ellipsoid.cartesianToCartographic(p1, carto2);\n  var numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  var heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * var polylines = new Cesium.PolylineCollection();\n * var polyline = polylines.add(...);\n * var positions = polyline.positions;\n * var modelMatrix = polylines.modelMatrix;\n * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  var cartesians = [];\n  var segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    var inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix\n    );\n\n    var origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin\n    );\n    var xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal\n      ),\n      wrapLongitudeXZNormal\n    );\n    var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n    var yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal\n      ),\n      wrapLongitudeYZNormal\n    );\n    var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n\n    var count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    var prev = cartesians[0];\n\n    var length = positions.length;\n    for (var i = 1; i < length; ++i) {\n      var cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        var intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          var offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  var positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    var granularity = defaultValue(\n      options.granularity,\n      CesiumMath.RADIANS_PER_DEGREE\n    );\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  var numPoints = 0;\n  var i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance\n    );\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nvar scratchCartographic0 = new Cartographic();\nvar scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  var positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  var numPoints = 0;\n  var i;\n\n  var c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0\n  );\n  var c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  var numberArray = PolylinePipeline.generateArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  var numberArray = PolylinePipeline.generateRhumbArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n"],"names":["PolylinePipeline","numberOfPoints","p0","p1","minDistance","distance","Cartesian3","Math","ceil","numberOfPointsRhumbLine","granularity","radiansDistanceSquared","pow","longitude","latitude","max","sqrt","cartoScratch","Cartographic","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","Matrix4","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","Plane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","EllipsoidGeodesic","ellipsoidRhumb","EllipsoidRhumbLine","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","defined","defaultValue","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","IntersectionTests","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","DeveloperError","Ellipsoid","WGS84","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","CesiumMath","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c1","c0","numberArray","size","unpack"],"mappings":"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"}