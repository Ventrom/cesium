{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n * the WGS84 ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(\n    options.numberOfLevelZeroTilesX,\n    2\n  );\n  this._numberOfLevelZeroTilesY = defaultValue(\n    options.numberOfLevelZeroTilesY,\n    1\n  );\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var west = CesiumMath.toDegrees(rectangle.west);\n  var south = CesiumMath.toDegrees(rectangle.south);\n  var east = CesiumMath.toDegrees(rectangle.east);\n  var north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  var rectangle = this._rectangle;\n\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  var xTileWidth = rectangle.width / xTiles;\n  var west = x * xTileWidth + rectangle.west;\n  var east = (x + 1) * xTileWidth + rectangle.west;\n\n  var yTileHeight = rectangle.height / yTiles;\n  var north = rectangle.north - y * yTileHeight;\n  var south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result\n) {\n  var rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  var xTiles = this.getNumberOfXTilesAtLevel(level);\n  var yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  var xTileWidth = rectangle.width / xTiles;\n  var yTileHeight = rectangle.height / yTiles;\n\n  var longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  var xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  var yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\nvar scratchDiagonalCartesianNE = new Cartesian3();\nvar scratchDiagonalCartesianSW = new Cartesian3();\nvar scratchDiagonalCartographic = new Cartographic();\nvar scratchCenterCartesian = new Cartesian3();\nvar scratchSurfaceCartesian = new Cartesian3();\n\nvar scratchBoundingSphere = new BoundingSphere();\nvar tilingScheme = new GeographicTilingScheme();\nvar scratchCorners = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nvar scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nvar ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  var initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n\n  initPromise = Resource.fetchJson(\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\")\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE\n    );\n    ellipsoid.cartographicToCartesian(\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW\n    );\n\n    Cartesian3.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian\n    );\n    var surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian\n    );\n    if (defined(surfacePosition)) {\n      var distance = Cartesian3.distance(\n        scratchCenterCartesian,\n        surfacePosition\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    var key = xyLevel.level + \"-\" + xyLevel.x + \"-\" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere\n  );\n\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1]\n  );\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2]\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3]\n  );\n\n  // Determine which tile the bounding rectangle is in\n  var lastLevelX = 0,\n    lastLevelY = 0;\n  var currentX = 0,\n    currentY = 0;\n  var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  var i;\n  for (i = 0; i <= maxLevel; ++i) {\n    var failed = false;\n    for (var j = 0; j < 4; ++j) {\n      var corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {Boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\nexport default ApproximateTerrainHeights;\n","import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nvar PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nvar PROJECTION_COUNT = PROJECTIONS.length;\n\nvar MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nvar MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nvar WALL_INITIAL_MIN_HEIGHT = 0.0;\nvar WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {Object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {Number} [options.width=1.0] The screen space width in pixels.\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * var geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {Number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {Boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {Boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._ellipsoid = Ellipsoid.WGS84;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection\n) {\n  var projectionIndex = 0;\n  for (var i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nvar cart3Scratch1 = new Cartesian3();\nvar cart3Scratch2 = new Cartesian3();\nvar cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  var up = direction(startTop, startBottom, cart3Scratch2);\n  var forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\nvar interpolatedBottomScratch = new Cartesian3();\nvar interpolatedTopScratch = new Cartesian3();\nvar interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  var ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  var surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  var interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch\n  );\n\n  var segments = Math.ceil(surfaceDistance / granularity);\n  var interpointDistance = surfaceDistance / segments;\n  var distanceFromStart = interpointDistance;\n  var pointsToAdd = segments - 1;\n  var packIndex = normalsArray.length;\n  for (var i = 0; i < pointsToAdd; i++) {\n    var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\n      distanceFromStart,\n      interpolatedCartographicScratch\n    );\n    var interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch\n    );\n    var interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nvar heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n\n  var positions = value._positions;\n  var positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (var i = 0; i < positionsLength; ++i) {\n    var cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var index = defaultValue(startingIndex, 0);\n  var positionsLength = array[index++];\n  var positions = new Array(positionsLength);\n\n  for (var i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  var granularity = array[index++];\n  var loop = array[index++] === 1.0;\n  var arcType = array[index++];\n\n  var ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  var projectionIndex = array[index++];\n  var scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nvar toPreviousScratch = new Cartesian3();\nvar toNextScratch = new Cartesian3();\nvar forwardScratch = new Cartesian3();\nvar vertexUpScratch = new Cartesian3();\nvar cosine90 = 0.0;\nvar cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result\n) {\n  var up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  var toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch\n  );\n  var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  var forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nvar XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nvar previousBottomScratch = new Cartesian3();\nvar vertexBottomScratch = new Cartesian3();\nvar vertexTopScratch = new Cartesian3();\nvar nextBottomScratch = new Cartesian3();\nvar vertexNormalScratch = new Cartesian3();\nvar intersectionScratch = new Cartesian3();\nvar cartographicScratch0 = new Cartographic();\nvar cartographicScratch1 = new Cartographic();\nvar cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  var loop = groundPolylineGeometry.loop;\n  var ellipsoid = groundPolylineGeometry._ellipsoid;\n  var granularity = groundPolylineGeometry.granularity;\n  var arcType = groundPolylineGeometry.arcType;\n  var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid\n  );\n\n  var minHeight = WALL_INITIAL_MIN_HEIGHT;\n  var maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  var index;\n  var i;\n\n  var positions = groundPolylineGeometry._positions;\n  var positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  var p0;\n  var p1;\n  var c0;\n  var c1;\n  var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  var intersection;\n  var intersectionCartographic;\n  var intersectionLongitude;\n  var splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  var cartographicsLength = splitPositions.length;\n\n  var cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  var cartographicsArray = [];\n  var normalsArray = [];\n  var bottomPositionsArray = [];\n  var topPositionsArray = [];\n\n  var previousBottom = previousBottomScratch;\n  var vertexBottom = vertexBottomScratch;\n  var vertexTop = vertexTopScratch;\n  var nextBottom = nextBottomScratch;\n  var vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  var startCartographic = cartographics[0];\n  var nextCartographic = cartographics[1];\n\n  var prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    var vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  var endCartographic = cartographics[cartographicsLength - 1];\n  var preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    var postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nvar lineDirectionScratch = new Cartesian3();\nvar matrix3Scratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    var vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    var angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    var quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch\n    );\n    var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal\n    );\n    return true;\n  }\n  return false;\n}\n\nvar endPosCartographicScratch = new Cartographic();\nvar normalStartpointScratch = new Cartesian3();\nvar normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result\n) {\n  var position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch\n  );\n  var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  var flipNormal = false;\n\n  var ellipsoid = projection._ellipsoid;\n  var normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  var normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nvar adjustHeightNormalScratch = new Cartesian3();\nvar adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  var adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  var adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nvar nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  var offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  var absStartLon = Math.abs(start.longitude);\n  var absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    var endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    var startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\n\nvar segmentStartTopScratch = new Cartesian3();\nvar segmentEndTopScratch = new Cartesian3();\nvar segmentStartBottomScratch = new Cartesian3();\nvar segmentEndBottomScratch = new Cartesian3();\nvar segmentStartNormalScratch = new Cartesian3();\nvar segmentEndNormalScratch = new Cartesian3();\n\nvar getHeightCartographics = [startCartographicScratch, endCartographicScratch];\nvar getHeightRectangleScratch = new Rectangle();\n\nvar adjustHeightStartTopScratch = new Cartesian3();\nvar adjustHeightEndTopScratch = new Cartesian3();\nvar adjustHeightStartBottomScratch = new Cartesian3();\nvar adjustHeightEndBottomScratch = new Cartesian3();\n\nvar segmentStart2DScratch = new Cartesian3();\nvar segmentEnd2DScratch = new Cartesian3();\nvar segmentStartNormal2DScratch = new Cartesian3();\nvar segmentEndNormal2DScratch = new Cartesian3();\n\nvar offsetScratch = new Cartesian3();\nvar startUpScratch = new Cartesian3();\nvar endUpScratch = new Cartesian3();\nvar rightScratch = new Cartesian3();\nvar startPlaneNormalScratch = new Cartesian3();\nvar endPlaneNormalScratch = new Cartesian3();\nvar encodeScratch = new EncodedCartesian3();\n\nvar encodeScratch2D = new EncodedCartesian3();\nvar forwardOffset2DScratch = new Cartesian3();\nvar right2DScratch = new Cartesian3();\n\nvar normalNudgeScratch = new Cartesian3();\n\nvar scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nvar REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes\n) {\n  var i;\n  var index;\n  var ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  var segmentCount = bottomPositionsArray.length / 3 - 1;\n  var vertexCount = segmentCount * 8;\n  var arraySizeVec4 = vertexCount * 4;\n  var indexCount = segmentCount * 36;\n\n  var indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  var positionsArray = new Float64Array(vertexCount * 3);\n\n  var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  var endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4\n  );\n  var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4\n  );\n\n  var startHiLo2D;\n  var offsetAndRight2D;\n  var startEndNormals2D;\n  var texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  var cartographicsLength = cartographicsArray.length / 2;\n  var length2D = 0.0;\n\n  var startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  var endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  var segmentStartCartesian = segmentStartTopScratch;\n  var segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  var positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian\n  );\n  var length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  var j;\n  index = 3;\n  var cartographicsIndex = 0;\n  var vec2sWriteIndex = 0;\n  var vec3sWriteIndex = 0;\n  var vec4sWriteIndex = 0;\n  var miterBroken = false;\n\n  var endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch\n  );\n  var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  var endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch\n  );\n\n  if (loop) {\n    var preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal\n      );\n    }\n  }\n\n  var lengthSoFar3D = 0.0;\n  var lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  var sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    var startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    var start2D;\n    var end2D;\n    var startGeometryNormal2D;\n    var endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    var segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    var encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch\n    );\n    var forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch\n    );\n    var forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    var startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    var endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    var texcoordNormalization3DX = segmentLength3D / length3D;\n    var texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    var segmentLength2D = 0.0;\n    var encodedStart2D;\n    var forwardOffset2D;\n    var right2D;\n    var texcoordNormalization2DX = 0.0;\n    var texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      var swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      var vec4Index = vec4sWriteIndex + j * 4;\n      var vec2Index = vec2sWriteIndex + j * 2;\n      var wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      var rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      var topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index\n      );\n\n      var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[\n        wIndex\n      ] = texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    var adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    var adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    var adjustHeightStartTop = adjustHeightStartTopScratch;\n    var adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    var getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch\n    );\n    var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid\n    );\n    var minHeight = minMaxHeights.minimumTerrainHeight;\n    var maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    sumHeights += minHeight;\n    sumHeights += maxHeight;\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    var normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  var indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  var boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0]\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1]\n  );\n  var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  var attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport defined from \"../Core/defined.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\n\nfunction createGroundPolylineGeometry(groundPolylineGeometry, offset) {\n  return ApproximateTerrainHeights.initialize().then(function () {\n    if (defined(offset)) {\n      groundPolylineGeometry = GroundPolylineGeometry.unpack(\n        groundPolylineGeometry,\n        offset\n      );\n    }\n    return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\n  });\n}\nexport default createGroundPolylineGeometry;\n"],"names":["GeographicTilingScheme","options","defaultValue","EMPTY_OBJECT","this","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_rectangle","rectangle","Rectangle","MAX_VALUE","_projection","GeographicProjection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","Check","defined","west","CesiumMath","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude","Cartesian2","scratchDiagonalCartesianNE","Cartesian3","scratchDiagonalCartesianSW","scratchDiagonalCartographic","Cartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","BoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","getTileXYLevel","fromRadians","i","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","failed","j","corner","initialize","initPromise","_initPromise","Resource","fetchJson","buildModuleUrl","then","json","_terrainHeights","getMinimumMaximumHeights","DeveloperError","xyLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","minimumTerrainHeight","max","maximumTerrainHeight","getBoundingSphere","fromRectangle3D","union","undefined","initialized","PROJECTIONS","WebMercatorProjection","PROJECTION_COUNT","length","MITER_BREAK_SMALL","cos","toRadians","MITER_BREAK_LARGE","WALL_INITIAL_MIN_HEIGHT","WALL_INITIAL_MAX_HEIGHT","GroundPolylineGeometry","positions","arcType","ArcType","GEODESIC","RHUMB","_positions","granularity","loop","_projectionIndex","_workerName","_scene3DOnly","packedLength","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","EllipsoidGeodesic","EllipsoidRhumbLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","heightlessCartographicScratch","cartographic","clone","toCartesian","target","origin","subtract","tangentDirection","value","array","startingIndex","typeOf","object","index","positionsLength","cartesian","unpack","Array","scene3DOnly","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","Plane","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","p0","p1","c0","c1","compute2dAttributes","intersection","intersectionCartographic","intersectionLongitude","rhumbLine","splitPositions","IntersectionTests","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicsLength","cartographics","fromCartesian","arrayRemoveDuplicates","vertexNormal","startCartographic","nextCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","length2D","startCartographicScratch","endCartographicScratch","segmentStartCartesian","segmentStartTopScratch","segmentEndCartesian","segmentEndTopScratch","project","length3D","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","segmentEndBottomScratch","endTop","endGeometryNormal","segmentEndNormalScratch","preEndBottom","segmentStartBottomScratch","breakMiter","lengthSoFar3D","lengthSoFar2D","sumHeights","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","startGeometryNormal","segmentStartNormalScratch","nudgeResult","nudgeCartographic","segmentStart2DScratch","direction2D","segmentEnd2DScratch","forwardOffset2DScratch","abs","segmentStartNormal2DScratch","segmentEndNormal2DScratch","projectNormal","sign","z","segmentLength3D","encodedStart","EncodedCartesian3","encodeScratch","forwardOffset","offsetScratch","rightScratch","startUp","startUpScratch","rightNormal","startPlaneNormal","startPlaneNormalScratch","endUp","endUpScratch","endPlaneNormal","endPlaneNormalScratch","encodedStart2D","forwardOffset2D","right2D","texcoordNormalization3DX","texcoordNormalization3DY","segmentLength2D","texcoordNormalization2DX","texcoordNormalization2DY","encodeScratch2D","swap","right2DScratch","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightStartBottomScratch","adjustHeightEndBottom","adjustHeightEndBottomScratch","adjustHeightStartTop","adjustHeightStartTopScratch","adjustHeightEndTop","adjustHeightEndTopScratch","getHeightsRectangle","fromCartographicArray","getHeightCartographics","getHeightRectangleScratch","minMaxHeights","adjustHeights","normalNudge","multiplyByScalar","normalNudgeScratch","nudgeXZ","indexOffset","REFERENCE_INDICES_LENGTH","REFERENCE_INDICES","boundingSpheres","scratchBoundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","Geometry","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","Matrix3","quaternionScratch","Quaternion","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","normal","projectedPosition","normalEndpoint","flipNormal","normalEndpointCartographic","normalEndpointProjected","adjustHeightNormalScratch","adjustHeightOffsetScratch","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","distanceForTop","nudgeDirectionScratch","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","absStartLon","absEndLon","PI","EPSILON11","endSign","startSign","typedArray","_projectNormal"],"mappings":"8gBA0BA,SAASA,EAAuBC,GAC9BA,EAAUC,eAAaD,EAASC,eAAaC,cAE7CC,KAAKC,WAAaH,eAAaD,EAAQK,UAAWC,aAAUC,OAC5DJ,KAAKK,WAAaP,eAAaD,EAAQS,UAAWC,aAAUC,WAC5DR,KAAKS,YAAc,IAAIC,wBAAqBV,KAAKC,YACjDD,KAAKW,yBAA2Bb,eAC9BD,EAAQe,wBACR,GAEFZ,KAAKa,yBAA2Bf,eAC9BD,EAAQiB,wBACR,GAIJC,OAAOC,iBAAiBpB,EAAuBqB,UAAW,CAMxDf,UAAW,CACTgB,IAAK,WACH,OAAOlB,KAAKC,aAShBK,UAAW,CACTY,IAAK,WACH,OAAOlB,KAAKK,aAShBc,WAAY,CACVD,IAAK,WACH,OAAOlB,KAAKS,gBAWlBb,EAAuBqB,UAAUG,yBAA2B,SAAUC,GACpE,OAAOrB,KAAKW,0BAA4BU,GAS1CzB,EAAuBqB,UAAUK,yBAA2B,SAAUD,GACpE,OAAOrB,KAAKa,0BAA4BQ,GAa1CzB,EAAuBqB,UAAUM,2BAA6B,SAC5DjB,EACAkB,GAGAC,QAAMC,QAAQ,YAAapB,GAG3B,IAAIqB,EAAOC,cAAWC,UAAUvB,EAAUqB,MACtCG,EAAQF,cAAWC,UAAUvB,EAAUwB,OACvCC,EAAOH,cAAWC,UAAUvB,EAAUyB,MACtCC,EAAQJ,cAAWC,UAAUvB,EAAU0B,OAE3C,OAAKN,UAAQF,IAIbA,EAAOG,KAAOA,EACdH,EAAOM,MAAQA,EACfN,EAAOO,KAAOA,EACdP,EAAOQ,MAAQA,EACRR,GAPE,IAAIjB,aAAUoB,EAAMG,EAAOC,EAAMC,IAsB5CpC,EAAuBqB,UAAUgB,wBAA0B,SACzDC,EACAC,EACAd,EACAG,GAEA,IAAIY,EAAmBpC,KAAKqC,kBAAkBH,EAAGC,EAAGd,EAAOG,GAK3D,OAJAY,EAAiBT,KAAOC,cAAWC,UAAUO,EAAiBT,MAC9DS,EAAiBN,MAAQF,cAAWC,UAAUO,EAAiBN,OAC/DM,EAAiBL,KAAOH,cAAWC,UAAUO,EAAiBL,MAC9DK,EAAiBJ,MAAQJ,cAAWC,UAAUO,EAAiBJ,OACxDI,GAcTxC,EAAuBqB,UAAUoB,kBAAoB,SACnDH,EACAC,EACAd,EACAG,GAEA,IAAIlB,EAAYN,KAAKK,WAEjBiC,EAAStC,KAAKoB,yBAAyBC,GACvCkB,EAASvC,KAAKsB,yBAAyBD,GAEvCmB,EAAalC,EAAUmC,MAAQH,EAC/BX,EAAOO,EAAIM,EAAalC,EAAUqB,KAClCI,GAAQG,EAAI,GAAKM,EAAalC,EAAUqB,KAExCe,EAAcpC,EAAUqC,OAASJ,EACjCP,EAAQ1B,EAAU0B,MAAQG,EAAIO,EAC9BZ,EAAQxB,EAAU0B,OAASG,EAAI,GAAKO,EAUxC,OARKhB,UAAQF,KACXA,EAAS,IAAIjB,aAAUoB,EAAMG,EAAOC,EAAMC,IAG5CR,EAAOG,KAAOA,EACdH,EAAOM,MAAQA,EACfN,EAAOO,KAAOA,EACdP,EAAOQ,MAAQA,EACRR,GAcT5B,EAAuBqB,UAAU2B,iBAAmB,SAClDC,EACAxB,EACAG,GAEA,IAAIlB,EAAYN,KAAKK,WACrB,GAAKE,aAAUuC,SAASxC,EAAWuC,GAAnC,CAKA,IAAIP,EAAStC,KAAKoB,yBAAyBC,GACvCkB,EAASvC,KAAKsB,yBAAyBD,GAEvCmB,EAAalC,EAAUmC,MAAQH,EAC/BI,EAAcpC,EAAUqC,OAASJ,EAEjCQ,EAAYF,EAASE,UACrBzC,EAAUyB,KAAOzB,EAAUqB,OAC7BoB,GAAanB,cAAWoB,QAG1B,IAAIC,GAAoBF,EAAYzC,EAAUqB,MAAQa,EAAc,EAC7CF,GAAnBW,IACFA,EAAkBX,EAAS,GAG7B,IAAIY,GACA5C,EAAU0B,MAAQa,EAASM,UAAYT,EAAe,EAK1D,OAJuBH,GAAnBW,IACFA,EAAkBX,EAAS,GAGxBb,UAAQF,IAIbA,EAAOU,EAAIe,EACXzB,EAAOW,EAAIe,EACJ1B,GALE,IAAI4B,cAAWH,EAAiBC,KCrO3C,IAAIG,EAA6B,IAAIC,cACjCC,EAA6B,IAAID,cACjCE,EAA8B,IAAIC,gBAClCC,EAAyB,IAAIJ,cAC7BK,EAA0B,IAAIL,cAE9BM,EAAwB,IAAIC,kBAC5BC,EAAe,IAAIlE,EACnBmE,EAAiB,CACnB,IAAIN,gBACJ,IAAIA,gBACJ,IAAIA,gBACJ,IAAIA,iBAEFO,EAAgB,IAAIZ,cAMpBa,GAA4B,GAwIhC,SAASC,EAAe5D,GACtBmD,gBAAaU,YACX7D,EAAUyB,KACVzB,EAAU0B,MACV,EACA+B,EAAe,IAEjBN,gBAAaU,YACX7D,EAAUqB,KACVrB,EAAU0B,MACV,EACA+B,EAAe,IAEjBN,gBAAaU,YACX7D,EAAUyB,KACVzB,EAAUwB,MACV,EACAiC,EAAe,IAEjBN,gBAAaU,YACX7D,EAAUqB,KACVrB,EAAUwB,MACV,EACAiC,EAAe,IAIjB,IAKIK,EALAC,EAAa,EACfC,EAAa,EACXC,EAAW,EACbC,EAAW,EACTC,EAAWR,GAA0BS,wBAEzC,IAAKN,EAAI,EAAGA,GAAKK,IAAYL,EAAG,CAE9B,IADA,IAAIO,GAAS,EACJC,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAC1B,IAAIC,EAASd,EAAea,GAE5B,GADAd,EAAalB,iBAAiBiC,EAAQT,EAAGJ,GAC/B,IAANY,EACFL,EAAWP,EAAc9B,EACzBsC,EAAWR,EAAc7B,OACpB,GAAIoC,IAAaP,EAAc9B,GAAKsC,IAAaR,EAAc7B,EAAG,CACvEwC,GAAS,EACT,OAIJ,GAAIA,EACF,MAGFN,EAAaE,EACbD,EAAaE,EAGf,GAAU,IAANJ,EAIJ,MAAO,CACLlC,EAAGmC,EACHlC,EAAGmC,EACHjD,MAAWoD,EAAJL,EAAeK,EAAWL,EAAI,GAhMzCH,GAA0Ba,WAAa,WACrC,IAAIC,EAAcd,GAA0Be,aAC5C,OAAItD,UAAQqD,GACHA,GAGTA,EAAcE,YAASC,UACrBC,kBAAe,0CACfC,KAAK,SAAUC,GACfpB,GAA0BqB,gBAAkBD,IAE9CpB,GAA0Be,aAAeD,IAW3Cd,GAA0BsB,yBAA2B,SACnDjF,EACAJ,GAIA,GADAuB,QAAMC,QAAQ,YAAapB,IACtBoB,UAAQuC,GAA0BqB,iBACrC,MAAM,IAAIE,iBACR,qHAIJtF,EAAYJ,eAAaI,EAAWC,aAAUC,OAE9C,IAAIqF,EAAUvB,EAAe5D,GAGzBoF,EAAmBzB,GAA0B0B,yBAC7CC,EAAmB3B,GAA0B4B,yBACjD,GAAInE,UAAQ+D,GAAU,CACpB,IAAIK,EAAML,EAAQpE,MAAQ,IAAMoE,EAAQvD,EAAI,IAAMuD,EAAQtD,EACtD4D,EAAU9B,GAA0BqB,gBAAgBQ,GACpDpE,UAAQqE,KACVL,EAAmBK,EAAQ,GAC3BH,EAAmBG,EAAQ,IAI7B7F,EAAU8F,wBACRzF,aAAU0F,UAAU3F,EAAWkD,GAC/BH,GAEFnD,EAAU8F,wBACRzF,aAAU2F,UAAU5F,EAAWkD,GAC/BD,GAGFD,cAAW6C,SACT5C,EACAF,EACAK,GAEF,IAAI0C,EAAkBlG,EAAUmG,uBAC9B3C,EACAC,GAEF,GAAIjC,UAAQ0E,GAAkB,CAC5B,IAAIE,EAAWhD,cAAWgD,SACxB5C,EACA0C,GAEFV,EAAmBa,KAAKC,IAAId,GAAmBY,QAE/CZ,EAAmBzB,GAA0B0B,yBASjD,MAAO,CACLc,qBANFf,EAAmBa,KAAKG,IACtBzC,GAA0B0B,yBAC1BD,GAKAiB,qBAAsBf,IAU1B3B,GAA0B2C,kBAAoB,SAAUtG,EAAWJ,GAGjE,GADAuB,QAAMC,QAAQ,YAAapB,IACtBoB,UAAQuC,GAA0BqB,iBACrC,MAAM,IAAIE,iBACR,qHAIJtF,EAAYJ,eAAaI,EAAWC,aAAUC,OAE9C,IAAIqF,EAAUvB,EAAe5D,GAGzBsF,EAAmB3B,GAA0B4B,yBACjD,GAAInE,UAAQ+D,GAAU,CACpB,IAAIK,EAAML,EAAQpE,MAAQ,IAAMoE,EAAQvD,EAAI,IAAMuD,EAAQtD,EACtD4D,EAAU9B,GAA0BqB,gBAAgBQ,GACpDpE,UAAQqE,KACVH,EAAmBG,EAAQ,IAI/B,IAAIvE,EAASqC,kBAAegD,gBAAgBvG,EAAWJ,EAAW,GAQlE,OAPA2D,kBAAegD,gBACbvG,EACAJ,EACA0F,EACAhC,GAGKC,kBAAeiD,MAAMtF,EAAQoC,EAAuBpC,IAqE7DyC,GAA0BS,wBAA0B,EACpDT,GAA0B4B,yBAA2B,IACrD5B,GAA0B0B,0BAA4B,IACtD1B,GAA0BqB,qBAAkByB,EAC5C9C,GAA0Be,kBAAe+B,EAEzChG,OAAOC,iBAAiBiD,GAA2B,CAQjD+C,YAAa,CACX9F,IAAK,WACH,OAAOQ,UAAQuC,GAA0BqB,qBClO/C,IAAI2B,EAAc,CAACvG,wBAAsBwG,yBACrCC,EAAmBF,EAAYG,OAE/BC,GAAoBd,KAAKe,IAAI1F,cAAW2F,UAAU,KAClDC,EAAoBjB,KAAKe,IAAI1F,cAAW2F,UAAU,MAYlDE,EAA0B,EAC1BC,EAA0B,IA8B9B,SAASC,EAAuB9H,GAE9B,IAAI+H,GADJ/H,EAAUC,eAAaD,EAASC,eAAaC,eACrB6H,UAGxB,IAAKlG,UAAQkG,IAAcA,EAAUR,OAAS,EAC5C,MAAM,IAAI5B,iBAAe,wCAE3B,GACE9D,UAAQ7B,EAAQgI,UAChBhI,EAAQgI,UAAYC,UAAQC,UAC5BlI,EAAQgI,UAAYC,UAAQE,MAE5B,MAAM,IAAIxC,iBACR,qEASJxF,KAAKyC,MAAQ3C,eAAaD,EAAQ4C,MAAO,GAEzCzC,KAAKiI,WAAaL,EAQlB5H,KAAKkI,YAAcpI,eAAaD,EAAQqI,YAAa,MAQrDlI,KAAKmI,KAAOrI,eAAaD,EAAQsI,MAAM,GAOvCnI,KAAK6H,QAAU/H,eAAaD,EAAQgI,QAASC,UAAQC,UAErD/H,KAAKC,WAAaE,aAAUC,MAG5BJ,KAAKoI,iBAAmB,EACxBpI,KAAKqI,YAAc,+BAGnBrI,KAAKsI,cAAe,EAGtBvH,OAAOC,iBAAiB2G,EAAuB1G,UAAW,CAQxDsH,aAAc,CACZrH,IAAK,WACH,OACE,EACyB,EAAzBlB,KAAKiI,WAAWb,OAChB,EACA,EACA,EACAjH,aAAUoI,aACV,EACA,MAcRZ,EAAuBa,0BAA4B,SACjDC,EACAC,GAGA,IADA,IAAIC,EAAkB,EACbvE,EAAI,EAAGA,EAAI+C,EAAkB/C,IACpC,GAAIsE,aAAyBzB,EAAY7C,GAAI,CAC3CuE,EAAkBvE,EAClB,MAIJqE,EAAuBL,iBAAmBO,EAC1CF,EAAuBxI,WAAayI,EAAcxI,WAGpD,IAAI0I,EAAgB,IAAItF,cACpBuF,EAAgB,IAAIvF,cACpBwF,EAAgB,IAAIxF,cACxB,SAASyF,EAAmBC,EAAOC,EAAKC,EAAWhJ,EAAWsB,GAC5D,IAAI2H,EAAcC,EAAYlJ,EAAW8I,EAAO,EAAKJ,GACjDS,EAAWD,EAAYlJ,EAAW8I,EAAOE,EAAWL,GACpDS,EAAYF,EAAYlJ,EAAW+I,EAAK,EAAKH,GAE7CS,EAAKC,GAAUH,EAAUF,EAAaN,GACtCY,EAAUD,GAAUF,EAAWH,EAAaL,GAGhD,OADAxF,cAAWoG,MAAMD,EAASF,EAAI/H,GACvB8B,cAAWqG,UAAUnI,EAAQA,GAGtC,IAAIoI,EAAkC,IAAInG,gBACtCoG,EAA4B,IAAIvG,cAChCwG,EAAyB,IAAIxG,cAC7ByG,EAA4B,IAAIzG,cACpC,SAAS0G,EACPhB,EACAC,EACAgB,EACAf,EACAhB,EACAL,EACA3H,EACAgK,EACAC,EACAC,EACAC,GAEA,GAAoB,IAAhBnC,EAAJ,CAIA,IAAIoC,EACAzC,IAAYC,UAAQC,SACtBuC,EAAgB,IAAIC,oBAAkBvB,EAAOC,EAAK/I,GACzC2H,IAAYC,UAAQE,QAC7BsC,EAAgB,IAAIE,qBAAmBxB,EAAOC,EAAK/I,IAGrD,IAAIuK,EAAkBH,EAAcG,gBACpC,KAAIA,EAAkBvC,GAkBtB,IAbA,IAAIwC,EAAqB3B,EACvBC,EACAC,EACAC,EACAhJ,EACA6J,GAGEY,EAAWpE,KAAKqE,KAAKH,EAAkBvC,GACvC2C,EAAqBJ,EAAkBE,EACvCG,EAAoBD,EACpBE,EAAcJ,EAAW,EACzBK,EAAYd,EAAa9C,OACpBhD,EAAI,EAAGA,EAAI2G,EAAa3G,IAAK,CACpC,IAAI6G,EAA2BX,EAAcY,gCAC3CJ,EACAlB,GAEEuB,EAAqB/B,EACvBlJ,EACA+K,EACAhB,EACAJ,GAEEuB,EAAkBhC,EACpBlJ,EACA+K,EACA/B,EACAY,GAGFxG,cAAW+H,KAAKX,EAAoBR,EAAcc,GAClD1H,cAAW+H,KAAKF,EAAoBhB,EAAsBa,GAC1D1H,cAAW+H,KAAKD,EAAiBhB,EAAmBY,GACpDX,EAAmBiB,KAAKL,EAAyB9H,UACjDkH,EAAmBiB,KAAKL,EAAyBlI,WAEjDiI,GAAa,EACbF,GAAqBD,IAIzB,IAAIU,EAAgC,IAAI9H,gBACxC,SAAS2F,EAAYlJ,EAAWsL,EAAc7I,EAAQnB,GAGpD,OAFAiC,gBAAagI,MAAMD,EAAcD,GACjCA,EAA8B5I,OAASA,EAChCc,gBAAaiI,YAClBH,EACArL,EACAsB,GA6FJ,SAASgI,GAAUmC,EAAQC,EAAQpK,GAGjC,OAFA8B,cAAWuI,SAASF,EAAQC,EAAQpK,GACpC8B,cAAWqG,UAAUnI,EAAQA,GACtBA,EAGT,SAASsK,EAAiBH,EAAQC,EAAQrC,EAAI/H,GAO5C,OANAA,EAASgI,GAAUmC,EAAQC,EAAQpK,GAGnCA,EAAS8B,cAAWoG,MAAMlI,EAAQ+H,EAAI/H,GACtCA,EAAS8B,cAAWqG,UAAUnI,EAAQA,GACtCA,EAAS8B,cAAWoG,MAAMH,EAAI/H,EAAQA,GA5FxCmG,EAAuB0D,KAAO,SAAUU,EAAOC,EAAOC,GAEpDxK,QAAMyK,OAAOC,OAAO,QAASJ,GAC7BtK,QAAMC,QAAQ,QAASsK,GAGvB,IAAII,EAAQtM,eAAamM,EAAe,GAEpCrE,EAAYmE,EAAM9D,WAClBoE,EAAkBzE,EAAUR,OAEhC4E,EAAMI,KAAWC,EAEjB,IAAK,IAAIjI,EAAI,EAAGA,EAAIiI,IAAmBjI,EAAG,CACxC,IAAIkI,EAAY1E,EAAUxD,GAC1Bd,cAAW+H,KAAKiB,EAAWN,EAAOI,GAClCA,GAAS,EAaX,OAVAJ,EAAMI,KAAWL,EAAM7D,YACvB8D,EAAMI,KAAWL,EAAM5D,KAAO,EAAM,EACpC6D,EAAMI,KAAWL,EAAMlE,QAEvB1H,aAAUkL,KAAKU,EAAM9L,WAAY+L,EAAOI,GACxCA,GAASjM,aAAUoI,aAEnByD,EAAMI,KAAWL,EAAM3D,iBACvB4D,EAAMI,KAAWL,EAAMzD,aAAe,EAAM,EAErC0D,GAUTrE,EAAuB4E,OAAS,SAAUP,EAAOC,EAAezK,GAE9DC,QAAMC,QAAQ,QAASsK,GAOvB,IAJA,IAAII,EAAQtM,eAAamM,EAAe,GACpCI,EAAkBL,EAAMI,KACxBxE,EAAY,IAAI4E,MAAMH,GAEjBjI,EAAI,EAAGA,EAAIiI,EAAiBjI,IACnCwD,EAAUxD,GAAKd,cAAWiJ,OAAOP,EAAOI,GACxCA,GAAS,EAGX,IAAIlE,EAAc8D,EAAMI,KACpBjE,EAA0B,IAAnB6D,EAAMI,KACbvE,EAAUmE,EAAMI,KAEhBlM,EAAYC,aAAUoM,OAAOP,EAAOI,GACxCA,GAASjM,aAAUoI,aAEnB,IAAII,EAAkBqD,EAAMI,KACxBK,EAAiC,IAAnBT,EAAMI,KAgBxB,OAdK1K,UAAQF,KACXA,EAAS,IAAImG,EAAuB,CAClCC,UAAWA,KAIfpG,EAAOyG,WAAaL,EACpBpG,EAAO0G,YAAcA,EACrB1G,EAAO2G,KAAOA,EACd3G,EAAOqG,QAAUA,EACjBrG,EAAOvB,WAAaC,EACpBsB,EAAO4G,iBAAmBO,EAC1BnH,EAAO8G,aAAemE,EAEfjL,GAmBT,IAAIkL,EAAoB,IAAIpJ,cACxBqJ,EAAgB,IAAIrJ,cACpBsJ,EAAiB,IAAItJ,cACrBuJ,EAAkB,IAAIvJ,cAG1B,SAASwJ,EACPC,EACAC,EACAC,EACAC,EACA1L,GAEA,IAAI+H,EAAKC,GAAUyD,EAAWD,EAAcH,GAGxCM,EAAarB,EACfiB,EACAC,EACAzD,EACAmD,GAEEU,EAAStB,EAAiBoB,EAAYF,EAAczD,EAAIoD,GAG5D,GACE/K,cAAWyL,cACT/J,cAAWgK,IAAIH,EAAYC,IAtBjB,EAwBVxL,cAAW2L,UAKb,OAFA/L,EAAS8B,cAAWoG,MAAMH,EAAI4D,EAAY3L,GAC1CA,EAAS8B,cAAWqG,UAAUnI,EAAQA,GAKxCA,EAAS8B,cAAWkK,IAAIJ,EAAQD,EAAY3L,GAC5CA,EAAS8B,cAAWqG,UAAUnI,EAAQA,GAGtC,IAAIiI,EAAUnG,cAAWoG,MAAMH,EAAI/H,EAAQoL,GAK3C,OAJItJ,cAAWgK,IAAIF,EAAQ3D,GAvCd,IAwCXjI,EAAS8B,cAAWmK,OAAOjM,EAAQA,IAG9BA,EAGT,IAAIkM,EAAWC,QAAMC,gBAAgBtK,cAAWuK,KAAMvK,cAAWwK,QAE7DC,EAAwB,IAAIzK,cAC5B0K,GAAsB,IAAI1K,cAC1B2K,GAAmB,IAAI3K,cACvB4K,GAAoB,IAAI5K,cACxB6K,GAAsB,IAAI7K,cAC1B8K,GAAsB,IAAI9K,cAC1B+K,GAAuB,IAAI5K,gBAC3B6K,GAAuB,IAAI7K,gBAC3B8K,GAAkC,IAAI9K,gBAS1CkE,EAAuB6G,eAAiB,SAAU/F,GAChD,IAYI2D,EACAhI,EAYAqK,EACAC,EACAC,EACAC,EA5BAC,GAAuBpG,EAAuBH,aAC9CH,EAAOM,EAAuBN,KAC9BjI,EAAYuI,EAAuBxI,WACnCiI,EAAcO,EAAuBP,YACrCL,EAAUY,EAAuBZ,QACjC1G,EAAa,IAAI8F,EAAYwB,EAAuBL,kBACtDlI,GAGE+J,EAAYxC,EACZyB,EAAYxB,EAKZE,EAAYa,EAAuBR,WACnCoE,EAAkBzE,EAAUR,OAER,IAApBiF,IACFlE,GAAO,GAUT,IACI2G,EACAC,EACAC,EAHAC,EAAY,IAAIzE,0BAAmBzD,OAAWA,EAAW7G,GAIzDgP,EAAiB,CAACtH,EAAU,IAChC,IAAKxD,EAAI,EAAGA,EAAIiI,EAAkB,EAAGjI,IACnCqK,EAAK7G,EAAUxD,GACfsK,EAAK9G,EAAUxD,EAAI,GACnB0K,EAAeK,oBAAkBC,iBAC/BX,EACAC,EACAhB,EACAU,KAGA1M,UAAQoN,IACPxL,cAAW+J,cAAcyB,EAAcL,EAAI7M,cAAWyN,WACtD/L,cAAW+J,cAAcyB,EAAcJ,EAAI9M,cAAWyN,YAEnD5G,EAAuBZ,UAAYC,UAAQC,SAC7CmH,EAAe5D,KAAKhI,cAAWmI,MAAMqD,IAC5BrG,EAAuBZ,UAAYC,UAAQE,QACpDgH,EAAwB9O,EAAUoP,wBAChCR,EACAT,IACAtL,UACF4L,EAAKzO,EAAUoP,wBAAwBb,EAAIJ,IAC3CO,EAAK1O,EAAUoP,wBAAwBZ,EAAIJ,IAC3CW,EAAUM,aAAaZ,EAAIC,GAC3BG,EAA2BE,EAAUO,8BACnCR,EACAT,IAEFO,EAAe5O,EAAU8F,wBACvB+I,EACAX,KAGA1M,UAAQoN,IACPxL,cAAW+J,cAAcyB,EAAcL,EAAI7M,cAAWyN,WACtD/L,cAAW+J,cAAcyB,EAAcJ,EAAI9M,cAAWyN,WAEvDH,EAAe5D,KAAKhI,cAAWmI,MAAMqD,MAI3CI,EAAe5D,KAAKoD,GAGlBvG,IACFsG,EAAK7G,EAAUyE,EAAkB,GACjCqC,EAAK9G,EAAU,GACfkH,EAAeK,oBAAkBC,iBAC/BX,EACAC,EACAhB,EACAU,KAGA1M,UAAQoN,IACPxL,cAAW+J,cAAcyB,EAAcL,EAAI7M,cAAWyN,WACtD/L,cAAW+J,cAAcyB,EAAcJ,EAAI9M,cAAWyN,YAEnD5G,EAAuBZ,UAAYC,UAAQC,SAC7CmH,EAAe5D,KAAKhI,cAAWmI,MAAMqD,IAC5BrG,EAAuBZ,UAAYC,UAAQE,QACpDgH,EAAwB9O,EAAUoP,wBAChCR,EACAT,IACAtL,UACF4L,EAAKzO,EAAUoP,wBAAwBb,EAAIJ,IAC3CO,EAAK1O,EAAUoP,wBAAwBZ,EAAIJ,IAC3CW,EAAUM,aAAaZ,EAAIC,GAC3BG,EAA2BE,EAAUO,8BACnCR,EACAT,IAEFO,EAAe5O,EAAU8F,wBACvB+I,EACAX,KAGA1M,UAAQoN,IACPxL,cAAW+J,cAAcyB,EAAcL,EAAI7M,cAAWyN,WACtD/L,cAAW+J,cAAcyB,EAAcJ,EAAI9M,cAAWyN,WAEvDH,EAAe5D,KAAKhI,cAAWmI,MAAMqD,OAK7C,IAAIW,EAAsBP,EAAe9H,OAErCsI,EAAgB,IAAIlD,MAAMiD,GAC9B,IAAKrL,EAAI,EAAGA,EAAIqL,EAAqBrL,IAAK,CACxC,IAAIoH,EAAe/H,gBAAakM,cAAcT,EAAe9K,GAAIlE,GACjEsL,EAAa7I,OAAS,EACtB+M,EAActL,GAAKoH,EASrB,MAFAiE,GAJAC,EAAgBE,wBACdF,EACAjM,gBAAa4J,gBAEqBjG,QAEV,GAA1B,CASA,IAAIiD,EAAqB,GACrBH,EAAe,GACfC,EAAuB,GACvBC,EAAoB,GAEpB2C,EAAiBgB,EACjBf,EAAegB,GACff,EAAYgB,GACZf,EAAagB,GACb2B,EAAe1B,GAGf2B,EAAoBJ,EAAc,GAClCK,EAAmBL,EAAc,GAyDrC,IAtDA3C,EAAiB3D,EACflJ,EAFyBwP,EAAcD,EAAsB,GAI7DxF,EACA8C,GAEFG,EAAa9D,EAAYlJ,EAAW6P,EAAkB9F,EAAWiD,GACjEF,EAAe5D,EACblJ,EACA4P,EACA7F,EACA+C,GAEFC,EAAY7D,EAAYlJ,EAAW4P,EAAmB5G,EAAW+D,GAG/D4C,EADE1H,EACa2E,EACbC,EACAC,EACAC,EACAC,EACA2C,GAGa9G,EACb+G,EACAC,EACA7G,EACAhJ,EACA2P,GAIJvM,cAAW+H,KAAKwE,EAAc3F,EAAc,GAC5C5G,cAAW+H,KAAK2B,EAAc7C,EAAsB,GACpD7G,cAAW+H,KAAK4B,EAAW7C,EAAmB,GAC9CC,EAAmBiB,KAAKwE,EAAkB3M,UAC1CkH,EAAmBiB,KAAKwE,EAAkB/M,WAE1CiH,EACE8F,EACAC,EACA9F,EACAf,EACAhB,EACAL,EACA3H,EACAgK,EACAC,EACAC,EACAC,GAIGjG,EAAI,EAAGA,EAAIqL,EAAsB,IAAKrL,EAAG,CAC5C2I,EAAiBzJ,cAAWmI,MAAMuB,EAAcD,GAChDC,EAAe1J,cAAWmI,MAAMyB,EAAYF,GAC5C,IAAIgD,EAAqBN,EAActL,GACvCgF,EAAYlJ,EAAW8P,EAAoB9G,EAAW+D,GACtD7D,EAAYlJ,EAAWwP,EAActL,EAAI,GAAI6F,EAAWiD,GAExDJ,EACEC,EACAC,EACAC,EACAC,EACA2C,GAGFzD,EAAQlC,EAAa9C,OACrB9D,cAAW+H,KAAKwE,EAAc3F,EAAckC,GAC5C9I,cAAW+H,KAAK2B,EAAc7C,EAAsBiC,GACpD9I,cAAW+H,KAAK4B,EAAW7C,EAAmBgC,GAC9C/B,EAAmBiB,KAAK0E,EAAmB7M,UAC3CkH,EAAmBiB,KAAK0E,EAAmBjN,WAE3CiH,EACE0F,EAActL,GACdsL,EAActL,EAAI,GAClB6F,EACAf,EACAhB,EACAL,EACA3H,EACAgK,EACAC,EACAC,EACAC,GAKJ,IAAI4F,EAAkBP,EAAcD,EAAsB,GACtDS,EAAqBR,EAAcD,EAAsB,GAU7D,GARAzC,EAAe5D,EACblJ,EACA+P,EACAhG,EACA+C,GAEFC,EAAY7D,EAAYlJ,EAAW+P,EAAiB/G,EAAW+D,GAE3D9E,EAAM,CACR,IAAIgI,EAAsBT,EAAc,GAcxCG,EAAe/C,EAbfC,EAAiB3D,EACflJ,EACAgQ,EACAjG,EACA8C,GAWAC,EACAC,EAVFC,EAAa9D,EACXlJ,EACAiQ,EACAlG,EACAiD,GAQA2C,QAGFA,EAAe9G,EACbmH,EACAD,EACA/G,EACAhJ,EACA2P,GAWJ,GAPAzD,EAAQlC,EAAa9C,OACrB9D,cAAW+H,KAAKwE,EAAc3F,EAAckC,GAC5C9I,cAAW+H,KAAK2B,EAAc7C,EAAsBiC,GACpD9I,cAAW+H,KAAK4B,EAAW7C,EAAmBgC,GAC9C/B,EAAmBiB,KAAK2E,EAAgB9M,UACxCkH,EAAmBiB,KAAK2E,EAAgBlN,WAEpCoF,EAAM,CAeR,IAdA6B,EACEiG,EACAH,EACA7F,EACAf,EACAhB,EACAL,EACA3H,EACAgK,EACAC,EACAC,EACAC,GAEF+B,EAAQlC,EAAa9C,OAChBhD,EAAI,EAAGA,EAAI,IAAKA,EACnB8F,EAAakC,EAAQhI,GAAK8F,EAAa9F,GACvC+F,EAAqBiC,EAAQhI,GAAK+F,EAAqB/F,GACvDgG,EAAkBgC,EAAQhI,GAAKgG,EAAkBhG,GAEnDiG,EAAmBiB,KAAKwE,EAAkB3M,UAC1CkH,EAAmBiB,KAAKwE,EAAkB/M,WAG5C,OAwQF,SACEoF,EACAhH,EACAgJ,EACAC,EACAF,EACAG,EACAwE,GAEA,IAAIzK,EACAgI,EAyBAgE,EACAC,EACAC,EACAC,EA3BArQ,EAAYiB,EAAWlB,WAGvBuQ,EAAerG,EAAqB/C,OAAS,EAAI,EACjDqJ,EAA6B,EAAfD,EACdE,EAA8B,EAAdD,EAChBE,EAA4B,GAAfH,EAEbI,EACY,MAAdH,EACI,IAAII,YAAYF,GAChB,IAAIG,YAAYH,GAClBI,EAAiB,IAAIC,aAA2B,EAAdP,GAElCQ,EAA2B,IAAIC,aAAaR,GAC5CS,EAA2B,IAAID,aAAaR,GAC5CU,EAA+B,IAAIF,aAAaR,GAChDW,EAA8C,IAAIH,aACpDR,GAEEY,EAAgD,IAAIJ,aACtDR,GAQE7B,IACFuB,EAAc,IAAIc,aAAaR,GAC/BL,EAAmB,IAAIa,aAAaR,GACpCJ,EAAoB,IAAIY,aAAaR,GACrCH,EAA0B,IAAIW,aAA2B,EAAdT,IAK7C,IAAIhB,EAAsBpF,EAAmBjD,OAAS,EAClDmK,EAAW,EAEXzB,EAAoB0B,GACxB1B,EAAkBnN,OAAS,EAC3B,IAAIsN,EAAkBwB,GACtBxB,EAAgBtN,OAAS,EAEzB,IAAI+O,EAAwBC,GACxBC,EAAsBC,GAE1B,GAAIhD,EAEF,IADAzC,EAAQ,EACHhI,EAAI,EAAGA,EAAIqL,EAAqBrL,IAEnC0L,EAAkB3M,SAAWkH,EAAmB+B,GAChD0D,EAAkB/M,UAAYsH,EAAmB+B,EAAQ,GACzD6D,EAAgB9M,SAAWkH,EAAmB+B,EAAQ,GACtD6D,EAAgBlN,UAAYsH,EAAmB+B,EAAQ,GAEvDsF,EAAwBvQ,EAAW2Q,QACjChC,EACA4B,GAEFE,EAAsBzQ,EAAW2Q,QAC/B7B,EACA2B,GAEFL,GAAYjO,cAAWgD,SACrBoL,EACAE,GAEFxF,GAAS,EAKb,IAAIC,EAAkBjC,EAAkBhD,OAAS,EACjDwK,EAAsBtO,cAAWiJ,OAC/BnC,EACA,EACAwH,GAEF,IAkBIhN,EAlBAmN,EAAW,EAGf,IADA3F,EAAQ,EACHhI,EAAI,EAAGA,EAAIiI,EAAiBjI,IAC/BsN,EAAwBpO,cAAWmI,MACjCmG,EACAF,GAEFE,EAAsBtO,cAAWiJ,OAC/BnC,EACAgC,EACAwF,GAEFG,GAAYzO,cAAWgD,SAASoL,EAAuBE,GACvDxF,GAAS,EAKXA,EAAQ,EACR,IAAI4F,EAAqB,EACrBC,EAAkB,EAClBC,EAAkB,EAClBC,EAAkB,EAClBC,GAAc,EAEd9I,EAAYhG,cAAWiJ,OACzBpC,EACA,EACAkI,IAEEC,EAAShP,cAAWiJ,OAAOnC,EAAmB,EAAGyH,IACjDU,EAAoBjP,cAAWiJ,OACjCrC,EACA,EACAsI,IAGF,GAAIrK,EAAM,CACR,IAAIsK,EAAenP,cAAWiJ,OAC5BpC,EACAA,EAAqB/C,OAAS,EAC9BsL,IAEEC,GAAWJ,EAAmBE,EAAcnJ,EAAWgJ,KAEzDC,EAAoBjP,cAAWmK,OAC7B8E,EACAA,IAKN,IAAIK,EAAgB,EAChBC,EAAgB,EAGhBC,EAAa,EAEjB,IAAK1O,EAAI,EAAGA,EAAIoM,EAAcpM,IAAK,CACjC,IAiCI2O,EACAC,EACAC,EACAC,EApCA/J,EAAc7F,cAAWmI,MAAMnC,EAAWoJ,IAC1CrJ,EAAW/F,cAAWmI,MAAM6G,EAAQX,IACpCwB,EAAsB7P,cAAWmI,MACnC8G,EACAa,IAkCF,GA/BIhB,IACFe,EAAsB7P,cAAWmK,OAC/B0F,EACAA,IAIJ7J,EAAYhG,cAAWiJ,OACrBpC,EACAiC,EACAiG,IAEFC,EAAShP,cAAWiJ,OAAOnC,EAAmBgC,EAAOyF,IACrDU,EAAoBjP,cAAWiJ,OAC7BrC,EACAkC,EACAoG,IAGFJ,EAAcO,GAAWJ,EAAmBpJ,EAAaG,EAAWgJ,GAGpExC,EAAkB3M,SAAWkH,EAAmB2H,GAChDlC,EAAkB/M,UAAYsH,EAAmB2H,EAAqB,GACtE/B,EAAgB9M,SAAWkH,EAAmB2H,EAAqB,GACnE/B,EAAgBlN,UAAYsH,EAAmB2H,EAAqB,GAMhEnD,EAAqB,CACvB,IAAIwE,EAAcC,GAAkBxD,EAAmBG,GACvD8C,EAAU5R,EAAW2Q,QAAQhC,EAAmByD,IAEhD,IAAIC,GAAchK,GADlBwJ,EAAQ7R,EAAW2Q,QAAQ7B,EAAiBwD,IACTV,EAASW,IAC5CF,GAAYrR,EAAIoE,KAAKoN,IAAIH,GAAYrR,GAErC8Q,EAAwBW,GACxBV,EAAsBW,GAEJ,IAAhBR,GACA/P,cAAWgK,IAAIkG,GAAalQ,cAAWwK,QAAUzG,IAKjD4L,EAAwBa,GACtB3S,EACA2O,EACAqD,EACAJ,EACAa,IAEFV,EAAsBY,GACpB3S,EACA8O,EACAsC,EACAS,EACAa,KAEuB,IAAhBR,GAETH,EAAsBY,GACpB3S,EACA8O,EACAsC,EACAS,EACAa,IAEFZ,EAAsB/Q,EAAI,EAG1B+Q,EAAsB9Q,EAAIP,cAAWmS,KACnCjE,EAAkB/M,UAAYwD,KAAKoN,IAAI1D,EAAgBlN,YAEzDkQ,EAAsBe,EAAI,IAG1Bf,EAAwBa,GACtB3S,EACA2O,EACAqD,EACAJ,EACAa,IAEFV,EAAoBhR,EAAI,EAGxBgR,EAAoB/Q,EAAIP,cAAWmS,KACjCjE,EAAkB/M,UAAYkN,EAAgBlN,WAEhDmQ,EAAoBc,EAAI,GAc5B,IAAIC,GAAkB3Q,cAAWgD,SAAS+C,EAAUiJ,GAEhD4B,GAAeC,qBAAkBxE,cACnCxG,EACAiL,IAEEC,GAAgB/Q,cAAWuI,SAC7BvC,EACAH,EACAmL,IAEE7K,GAAUnG,cAAWqG,UAAU0K,GAAeE,IAE9CC,GAAUlR,cAAWuI,SAASxC,EAAUF,EAAasL,IACzDD,GAAUlR,cAAWqG,UAAU6K,GAASA,IACxC,IAAIE,GAAcpR,cAAWoG,MAAMD,GAAS+K,GAASD,IACrDG,GAAcpR,cAAWqG,UAAU+K,GAAaA,IAEhD,IAAIC,GAAmBrR,cAAWoG,MAChC8K,GACArB,EACAyB,IAEFD,GAAmBrR,cAAWqG,UAAUgL,GAAkBA,IAE1D,IAAIE,GAAQvR,cAAWuI,SAASyG,EAAQhJ,EAAWwL,IACnDD,GAAQvR,cAAWqG,UAAUkL,GAAOA,IACpC,IAAIE,GAAiBzR,cAAWoG,MAC9B6I,EACAsC,GACAG,IAEFD,GAAiBzR,cAAWqG,UAAUoL,GAAgBA,IAEtD,IAKIE,GACAC,GACAC,GAPAC,GAA2BnB,GAAkBlC,EAC7CsD,GAA2BzC,EAAgBb,EAG3CuD,GAAkB,EAIlBC,GAA2B,EAC3BC,GAA2B,EAC/B,GAAI3G,EAAqB,CACvByG,GAAkBhS,cAAWgD,SAASyM,EAASC,GAE/CiC,GAAiBd,qBAAkBxE,cACjCoD,EACA0C,IAEFP,GAAkB5R,cAAWuI,SAC3BmH,EACAD,EACAW,IAMF,IAAIgC,IADJP,GAAU7R,cAAWqG,UAAUuL,GAAiBS,KAC7BzT,EACnBiT,GAAQjT,EAAIiT,GAAQhT,EACpBgT,GAAQhT,GAAKuT,GAEbH,GAA2BD,GAAkB/D,EAC7CiE,GAA2B3C,EAAgBtB,EAG7C,IAAK3M,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACtB,IAAIgR,GAAYzD,EAAsB,EAAJvN,EAC9BiR,GAAY5D,EAAsB,EAAJrN,EAC9BkR,GAASF,GAAY,EAIrBG,GAAiBnR,EAAI,EAAI,GAAO,EAChCoR,GAAsB,IAANpR,GAAiB,IAANA,GAAiB,IAANA,GAAiB,IAANA,EAAU,GAAO,EAGtEtB,cAAW+H,KAAK6I,GAAa+B,KAAMhF,EAA0B2E,IAC7D3E,EAAyB6E,IAAUzB,GAAcnS,EAEjDoB,cAAW+H,KAAK6I,GAAagC,IAAK/E,EAA0ByE,IAC5DzE,EAAyB2E,IAAUzB,GAAclS,EAEjDmB,cAAW+H,KACTsJ,GACAvD,EACAwE,IAEFxE,EAA6B0E,IAAUzB,GAAcL,EAErD1Q,cAAW+H,KACT0J,GACA1D,EACAuE,IAEFvE,EAA4CyE,IAC1CV,GAA2BW,GAE7BzS,cAAW+H,KACTqJ,GACApD,EACAsE,IAGF,IAAIO,GAAwBd,GAA2BW,GACzB,IAA1BG,IAAiCH,GAAgB,IACnDG,GAAwB,GAE1B7E,EACEwE,IACEK,GAGAtH,IACFuB,EAAYwF,IAAaX,GAAegB,KAAK/T,EAC7CkO,EAAYwF,GAAY,GAAKX,GAAegB,KAAK9T,EACjDiO,EAAYwF,GAAY,GAAKX,GAAeiB,IAAIhU,EAChDkO,EAAYwF,GAAY,GAAKX,GAAeiB,IAAI/T,EAEhDmO,EAAkBsF,KAAc3C,EAAsB9Q,EACtDmO,EAAkBsF,GAAY,GAAK3C,EAAsB/Q,EACzDoO,EAAkBsF,GAAY,GAAK1C,EAAoB/Q,EACvDmO,EAAkBsF,GAAY,IAAM1C,EAAoBhR,EAExDmO,EAAiBuF,IAAaV,GAAgBhT,EAC9CmO,EAAiBuF,GAAY,GAAKV,GAAgB/S,EAClDkO,EAAiBuF,GAAY,GAAKT,GAAQjT,EAC1CmO,EAAiBuF,GAAY,GAAKT,GAAQhT,EAE1CoO,EAAwBsF,IACtBN,GAA2BQ,GAGC,KAD9BI,GAAwBX,GAA2BQ,KACdA,GAAgB,IACnDG,GAAwB,GAE1B5F,EAAwBsF,GAAY,GAAKM,IAK7C,IAAIC,GAA0BC,GAC1BC,GAAwBC,GACxBC,GAAuBC,GACvBC,GAAqBC,GAErBC,GAAsBrW,aAAUsW,sBAClCC,GACAC,IAEEC,GAAgB/S,GAA0BsB,yBAC5CqR,GACA1W,GAEE+J,GAAY+M,GAAcvQ,qBAC1ByC,GAAY8N,GAAcrQ,qBAE9BmM,GAAc7I,GACd6I,GAAc5J,GAEd+N,GACE9N,EACAE,EACAY,GACAf,GACAkN,GACAI,IAEFS,GACE3N,EACAgJ,EACArI,GACAf,GACAoN,GACAI,IAIF,IAAIQ,GAAc5T,cAAW6T,iBAC3BzC,GACA9S,cAAW2L,SACX6J,IAEF9T,cAAWkK,IACT4I,GACAc,GACAd,IAEF9S,cAAWkK,IAAI8I,GAAuBY,GAAaZ,IACnDhT,cAAWkK,IAAIgJ,GAAsBU,GAAaV,IAClDlT,cAAWkK,IAAIkJ,GAAoBQ,GAAaR,IAGhDW,GAAQjB,GAAyBE,IACjCe,GAAQb,GAAsBE,IAE9BpT,cAAW+H,KAAK+K,GAAyBrF,EAAgBmB,GACzD5O,cAAW+H,KAAKiL,GAAuBvF,EAAgBmB,EAAkB,GACzE5O,cAAW+H,KAAKqL,GAAoB3F,EAAgBmB,EAAkB,GACtE5O,cAAW+H,KAAKmL,GAAsBzF,EAAgBmB,EAAkB,GAExEgF,GAAc5T,cAAW6T,iBACvBzC,IACC,EAAM9S,cAAW2L,SAClB6J,IAEF9T,cAAWkK,IACT4I,GACAc,GACAd,IAEF9S,cAAWkK,IAAI8I,GAAuBY,GAAaZ,IACnDhT,cAAWkK,IAAIgJ,GAAsBU,GAAaV,IAClDlT,cAAWkK,IAAIkJ,GAAoBQ,GAAaR,IAEhDW,GAAQjB,GAAyBE,IACjCe,GAAQb,GAAsBE,IAE9BpT,cAAW+H,KACT+K,GACArF,EACAmB,EAAkB,IAEpB5O,cAAW+H,KACTiL,GACAvF,EACAmB,EAAkB,IAEpB5O,cAAW+H,KAAKqL,GAAoB3F,EAAgBmB,EAAkB,IACtE5O,cAAW+H,KAAKmL,GAAsBzF,EAAgBmB,EAAkB,IAExEF,GAAsB,EACtB5F,GAAS,EAET6F,GAAmB,GACnBC,GAAmB,GACnBC,GAAmB,GAEnBS,GAAiBqB,GACjBpB,GAAiByC,GAInB,IAAIgC,GADJlL,EAAQ,EAER,IAAKhI,EAAI,EAAGA,EAAIoM,EAAcpM,IAAK,CACjC,IAAKQ,EAAI,EAAGA,EAAI2S,GAA0B3S,IACxCgM,EAAQxE,EAAQxH,GAAK4S,GAAkB5S,GAAK0S,GAE9CA,IAAe,EACflL,GAASmL,GAGX,IAAIE,GAAkBC,GACtB7T,kBAAe8T,aACbxN,EACA7G,cAAWuK,KACX,EACA4J,GAAgB,IAElB5T,kBAAe8T,aACbvN,EACA9G,cAAWuK,KACX,EACA4J,GAAgB,IAElB,IAAIG,GAAiB/T,kBAAegU,oBAAoBJ,IAGxDG,GAAeE,QAAUhF,GAA6B,EAAftC,GAEvC,IAAIuH,GAAa,CACflV,SAAU,IAAImV,qBAAkB,CAC9BC,kBAAmBC,qBAAkBC,OACrCC,uBAAwB,EACxBzO,WAAW,EACX0O,OAAQtH,IAEVE,yBAA0BqH,GACxBrH,GAEFE,yBAA0BmH,GACxBnH,GAEFC,6BAA8BkH,GAC5BlH,GAEFC,4CAA6CiH,GAC3CjH,GAEFC,8CAA+CgH,GAC7ChH,IAIAzC,IACFkJ,GAAW3H,YAAckI,GAAyBlI,GAClD2H,GAAW1H,iBAAmBiI,GAAyBjI,GACvD0H,GAAWzH,kBAAoBgI,GAAyBhI,GACxDyH,GAAWxH,wBAA0B,IAAIyH,qBAAkB,CACzDC,kBAAmBC,qBAAkBK,MACrCH,uBAAwB,EACxBzO,WAAW,EACX0O,OAAQ9H,KAIZ,OAAO,IAAIiI,YAAS,CAClBT,WAAYA,GACZnH,QAASA,EACTgH,eAAgBA,KAx0BXa,CACLtQ,EACAhH,EACAgJ,EACAC,EACAF,EACAG,EACAwE,KAOJ,IAAI6J,EAAuB,IAAIpV,cAC3BqV,EAAiB,IAAIC,WACrBC,EAAoB,IAAIC,cAC5B,SAASnG,GAAWJ,EAAmBpJ,EAAaG,EAAWgJ,GAC7D,IAAIyG,EAAgBvP,GAAUF,EAAWH,EAAauP,GAElDpL,EAAMhK,cAAWgK,IAAIyL,EAAexG,GACxC,GAAUlL,GAANiG,GAA2BA,EAAM9F,EAAmB,CACtD,IAAIwR,EAAWxP,GAAU8I,EAAQhJ,EAAWuD,GACxCoM,EACF3L,EAAM9F,EACF5F,cAAWsX,aACVtX,cAAWsX,YACdC,EAAaL,cAAWM,cAC1BJ,EACAC,EACAJ,GAEEQ,EAAiBT,WAAQU,eAAeH,EAAYR,GAMxD,OALAC,WAAQW,iBACNF,EACA9G,EACAA,IAEK,EAET,OAAO,EAGT,IAAIiH,EAA4B,IAAI/V,gBAChCgW,EAA0B,IAAInW,cAC9BoW,EAAwB,IAAIpW,cAChC,SAASwQ,GACP3S,EACAqK,EACAmO,EACAC,EACApY,GAEA,IAAIqB,EAAWY,gBAAaiI,YAC1BF,EACArK,EAAWlB,WACXwZ,GAEEI,EAAiBvW,cAAWkK,IAAI3K,EAAU8W,EAAQD,GAClDI,GAAa,EAEb5Z,EAAYiB,EAAWlB,WACvB8Z,EAA6B7Z,EAAUoP,wBACzCuK,EACAL,GAOAjT,KAAKoN,IAAInI,EAAazI,UAAYgX,EAA2BhX,WAC7DnB,cAAWsX,cAEXY,GAAa,EACbD,EAAiBvW,cAAWuI,SAC1BhJ,EACA8W,EACAD,GAEFK,EAA6B7Z,EAAUoP,wBACrCuK,EACAL,IAIJO,EAA2BpX,OAAS,EACpC,IAAIqX,EAA0B7Y,EAAW2Q,QACvCiI,EACAvY,GAYF,OAVAA,EAAS8B,cAAWuI,SAClBmO,EACAJ,EACApY,IAEKwS,EAAI,EACXxS,EAAS8B,cAAWqG,UAAUnI,EAAQA,GAClCsY,GACFxW,cAAWmK,OAAOjM,EAAQA,GAErBA,EAGT,IAAIyY,GAA4B,IAAI3W,cAChC4W,GAA4B,IAAI5W,cACpC,SAAS2T,GACPkD,EACAC,EACAnQ,EACAf,EACAmR,EACAC,GAGA,IAAIC,EAAqBjX,cAAWuI,SAClCuO,EACAD,EACAF,IAEF3W,cAAWqG,UAAU4Q,EAAoBA,GAEzC,IAAIC,EAAoBvQ,EAAYxC,EAChCgT,EAAqBnX,cAAW6T,iBAClCoD,EACAC,EACAN,IAEF5W,cAAWkK,IAAI2M,EAAQM,EAAoBJ,GAE3C,IAAIK,EAAiBxR,EAAYxB,EACjC+S,EAAqBnX,cAAW6T,iBAC9BoD,EACAG,EACAR,IAEF5W,cAAWkK,IAAI4M,EAAKK,EAAoBH,GAG1C,IAAIK,EAAwB,IAAIrX,cAChC,SAAS+T,GAAQrO,EAAOC,GACtB,IAAI2R,EAAoBjN,QAAMkN,iBAAiBnN,EAAU1E,GACrD8R,EAAkBnN,QAAMkN,iBAAiBnN,EAAUzE,GACnD8R,EAASJ,EAET/Y,cAAWyL,cAAcuN,EAAmB,EAAKhZ,cAAWoZ,WAC9DD,EAASvR,GAAUP,EAAKD,EAAO+R,GAC/BzX,cAAW6T,iBAAiB4D,EAAQnZ,cAAWoZ,SAAUD,GACzDzX,cAAWkK,IAAIxE,EAAO+R,EAAQ/R,IAE9BpH,cAAWyL,cAAcyN,EAAiB,EAAKlZ,cAAWoZ,YAE1DD,EAASvR,GAAUR,EAAOC,EAAK8R,GAC/BzX,cAAW6T,iBAAiB4D,EAAQnZ,cAAWoZ,SAAUD,GACzDzX,cAAWkK,IAAIvE,EAAK8R,EAAQ9R,IAOhC,SAASqK,GAAkBtK,EAAOC,GAChC,IAAIgS,EAAc1U,KAAKoN,IAAI3K,EAAMjG,WAC7BmY,EAAY3U,KAAKoN,IAAI1K,EAAIlG,WAC7B,GACEnB,cAAWyL,cAAc4N,EAAarZ,cAAWuZ,GAAIvZ,cAAWwZ,WAChE,CACA,IAAIC,EAAUzZ,cAAWmS,KAAK9K,EAAIlG,WAElC,OADAiG,EAAMjG,UAAYsY,GAAWJ,EAAcrZ,cAAWwZ,WAC/C,EACF,GACLxZ,cAAWyL,cAAc6N,EAAWtZ,cAAWuZ,GAAIvZ,cAAWwZ,WAC9D,CACA,IAAIE,EAAY1Z,cAAWmS,KAAK/K,EAAMjG,WAEtC,OADAkG,EAAIlG,UAAYuY,GAAaJ,EAAYtZ,cAAWwZ,WAC7C,EAET,OAAO,EAGT,IAAI5J,GAA2B,IAAI/N,gBAC/BgO,GAAyB,IAAIhO,gBAE7BkO,GAAyB,IAAIrO,cAC7BuO,GAAuB,IAAIvO,cAC3BoP,GAA4B,IAAIpP,cAChC+O,GAA0B,IAAI/O,cAC9B8P,GAA4B,IAAI9P,cAChCkP,GAA0B,IAAIlP,cAE9BwT,GAAyB,CAACtF,GAA0BC,IACpDsF,GAA4B,IAAIxW,aAEhCkW,GAA8B,IAAInT,cAClCqT,GAA4B,IAAIrT,cAChC+S,GAAiC,IAAI/S,cACrCiT,GAA+B,IAAIjT,cAEnCiQ,GAAwB,IAAIjQ,cAC5BmQ,GAAsB,IAAInQ,cAC1BsQ,GAA8B,IAAItQ,cAClCuQ,GAA4B,IAAIvQ,cAEhCgR,GAAgB,IAAIhR,cACpBmR,GAAiB,IAAInR,cACrBwR,GAAe,IAAIxR,cACnBiR,GAAe,IAAIjR,cACnBsR,GAA0B,IAAItR,cAC9B0R,GAAwB,IAAI1R,cAC5B8Q,GAAgB,IAAID,qBAEpBsB,GAAkB,IAAItB,qBACtBT,GAAyB,IAAIpQ,cAC7BqS,GAAiB,IAAIrS,cAErB8T,GAAqB,IAAI9T,cAEzBoU,GAAyB,CAAC,IAAI7T,kBAAkB,IAAIA,mBAGpD2T,GAAoB,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEED,GAA2BC,GAAkBpQ,OA0kBjD,SAASkR,GAAyBiD,GAChC,OAAO,IAAIvD,qBAAkB,CAC3BC,kBAAmBC,qBAAkBK,MACrCH,uBAAwB,EACxBzO,WAAW,EACX0O,OAAQkD,WAgBZ5T,EAAuB6T,eAAiB1H,GC7mDxC,SAAsCrL,EAAwBsS,GAC5D,OAAO9W,GAA0Ba,aAAaM,KAAK,WAOjD,OANI1D,UAAQqZ,KACVtS,EAAyBd,EAAuB4E,OAC9C9D,EACAsS,IAGGpT,EAAuB6G,eAAe/F"}