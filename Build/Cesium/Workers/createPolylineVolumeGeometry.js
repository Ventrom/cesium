define(["./when-54c2dc71","./Cartesian2-15709417","./arrayRemoveDuplicates-b5ccac6b","./BoundingRectangle-9d91ffef","./Transforms-c00dcfdd","./ComponentDatatype-a26dd044","./PolylineVolumeGeometryLibrary-6c9cb4ba","./Check-6c0211bc","./GeometryAttribute-c2f3a6a0","./GeometryAttributes-4fcfcf40","./GeometryPipeline-31fd0b9c","./IndexDatatype-eaebd63b","./Math-fbfbe3b1","./PolygonPipeline-5326ae1a","./VertexFormat-4d8b817a","./RuntimeError-2109023a","./WebGLConstants-76bb35d1","./EllipsoidTangentPlane-989039a6","./IntersectionTests-9d9af9db","./Plane-ff99a7c3","./PolylinePipeline-53cbf02f","./EllipsoidGeodesic-e0adc5e7","./EllipsoidRhumbLine-281c49be","./AttributeCompression-42df7d39","./EncodedCartesian3-8590615c"],function(c,u,o,a,T,G,l,g,A,R,I,O,n,S,y,e,t,r,i,s,d,p,h,f,m){"use strict";var v={};function q(e,t){if(!c.defined(e))throw new g.DeveloperError("identifier is required.");c.defined(v[e])||(v[e]=!0,console.warn(c.defaultValue(t,e)))}function b(e){var t=(e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT)).polylinePositions,r=e.shapePositions;if(!c.defined(t))throw new g.DeveloperError("options.polylinePositions is required.");if(!c.defined(r))throw new g.DeveloperError("options.shapePositions is required.");this._positions=t,this._shape=r,this._ellipsoid=u.Ellipsoid.clone(c.defaultValue(e.ellipsoid,u.Ellipsoid.WGS84)),this._cornerType=c.defaultValue(e.cornerType,l.CornerType.ROUNDED),this._vertexFormat=y.VertexFormat.clone(c.defaultValue(e.vertexFormat,y.VertexFormat.DEFAULT)),this._granularity=c.defaultValue(e.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";var i=1+t.length*u.Cartesian3.packedLength;i+=1+r.length*u.Cartesian2.packedLength,this.packedLength=i+u.Ellipsoid.packedLength+y.VertexFormat.packedLength+2}q.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",q.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",q.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",q.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",b.pack=function(e,t,r){if(!c.defined(e))throw new g.DeveloperError("value is required");if(!c.defined(t))throw new g.DeveloperError("array is required");var i;r=c.defaultValue(r,0);var n=e._positions,o=n.length;for(t[r++]=o,i=0;i<o;++i,r+=u.Cartesian3.packedLength)u.Cartesian3.pack(n[i],t,r);var a=e._shape;for(o=a.length,t[r++]=o,i=0;i<o;++i,r+=u.Cartesian2.packedLength)u.Cartesian2.pack(a[i],t,r);return u.Ellipsoid.pack(e._ellipsoid,t,r),r+=u.Ellipsoid.packedLength,y.VertexFormat.pack(e._vertexFormat,t,r),r+=y.VertexFormat.packedLength,t[r++]=e._cornerType,t[r]=e._granularity,t};var E=u.Ellipsoid.clone(u.Ellipsoid.UNIT_SPHERE),w=new y.VertexFormat,P={polylinePositions:void 0,shapePositions:void 0,ellipsoid:E,vertexFormat:w,cornerType:void 0,granularity:void 0};b.unpack=function(e,t,r){if(!c.defined(e))throw new g.DeveloperError("array is required");var i;t=c.defaultValue(t,0);var n=e[t++],o=new Array(n);for(i=0;i<n;++i,t+=u.Cartesian3.packedLength)o[i]=u.Cartesian3.unpack(e,t);n=e[t++];var a=new Array(n);for(i=0;i<n;++i,t+=u.Cartesian2.packedLength)a[i]=u.Cartesian2.unpack(e,t);var l=u.Ellipsoid.unpack(e,t,E);t+=u.Ellipsoid.packedLength;var s=y.VertexFormat.unpack(e,t,w);t+=y.VertexFormat.packedLength;var d=e[t++],p=e[t];return c.defined(r)?(r._positions=o,r._shape=a,r._ellipsoid=u.Ellipsoid.clone(l,r._ellipsoid),r._vertexFormat=y.VertexFormat.clone(s,r._vertexFormat),r._cornerType=d,r._granularity=p,r):(P.polylinePositions=o,P.shapePositions=a,P.cornerType=d,P.granularity=p,new b(P))};var _=new a.BoundingRectangle;return b.createGeometry=function(e){var t=e._positions,r=o.arrayRemoveDuplicates(t,u.Cartesian3.equalsEpsilon),i=e._shape;if(i=l.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(i),!(r.length<2||i.length<3)){S.PolygonPipeline.computeWindingOrder2D(i)===S.WindingOrder.CLOCKWISE&&i.reverse();var n=a.BoundingRectangle.fromPoints(i,_);return function(e,t,r,i){var n=new R.GeometryAttributes;i.position&&(n.position=new A.GeometryAttribute({componentDatatype:G.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));var o,a,l,s,d,p,c=t.length,u=e.length/3,g=(u-2*c)/(2*c),y=S.PolygonPipeline.triangulate(t),h=(g-1)*c*6+2*y.length,f=O.IndexDatatype.createTypedArray(u,h),m=2*c,v=0;for(o=0;o<g-1;o++){for(a=0;a<c-1;a++)p=(l=2*a+o*c*2)+m,d=(s=l+1)+m,f[v++]=s,f[v++]=l,f[v++]=d,f[v++]=d,f[v++]=l,f[v++]=p;d=(s=1+(l=2*c-2+o*c*2))+m,p=l+m,f[v++]=s,f[v++]=l,f[v++]=d,f[v++]=d,f[v++]=l,f[v++]=p}if(i.st||i.tangent||i.bitangent){var b,E,w=new Float32Array(2*u),P=1/(g-1),_=1/r.height,x=r.height/2,k=0;for(o=0;o<g;o++){for(b=o*P,E=_*(t[0].y+x),w[k++]=b,w[k++]=E,a=1;a<c;a++)E=_*(t[a].y+x),w[k++]=b,w[k++]=E,w[k++]=b,w[k++]=E;E=_*(t[0].y+x),w[k++]=b,w[k++]=E}for(a=0;a<c;a++)b=0,E=_*(t[a].y+x),w[k++]=b,w[k++]=E;for(a=0;a<c;a++)b=(g-1)*P,E=_*(t[a].y+x),w[k++]=b,w[k++]=E;n.st=new A.GeometryAttribute({componentDatatype:G.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(w)})}var C=u-2*c;for(o=0;o<y.length;o+=3){var V=y[o]+C,D=y[o+1]+C,L=y[o+2]+C;f[v++]=V,f[v++]=D,f[v++]=L,f[v++]=L+c,f[v++]=D+c,f[v++]=V+c}var F=new A.Geometry({attributes:n,indices:f,boundingSphere:T.BoundingSphere.fromVertices(e),primitiveType:A.PrimitiveType.TRIANGLES});if(i.normal&&(F=I.GeometryPipeline.computeNormal(F)),i.tangent||i.bitangent){try{F=I.GeometryPipeline.computeTangentAndBitangent(F)}catch(e){q("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(F.attributes.tangent=void 0),i.bitangent||(F.attributes.bitangent=void 0),i.st||(F.attributes.st=void 0)}return F}(l.PolylineVolumeGeometryLibrary.computePositions(r,i,n,e,!0),i,n,e._vertexFormat)}},function(e,t){return c.defined(t)&&(e=b.unpack(e,t)),e._ellipsoid=u.Ellipsoid.clone(e._ellipsoid),b.createGeometry(e)}});
//# sourceMappingURL=createPolylineVolumeGeometry.js.map
