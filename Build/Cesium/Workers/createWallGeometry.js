define(["./when-54c2dc71","./Cartesian2-15709417","./Transforms-c00dcfdd","./ComponentDatatype-a26dd044","./Check-6c0211bc","./GeometryAttribute-c2f3a6a0","./GeometryAttributes-4fcfcf40","./IndexDatatype-eaebd63b","./Math-fbfbe3b1","./VertexFormat-4d8b817a","./WallGeometryLibrary-ddb9104e","./RuntimeError-2109023a","./WebGLConstants-76bb35d1","./arrayRemoveDuplicates-b5ccac6b","./PolylinePipeline-53cbf02f","./EllipsoidGeodesic-e0adc5e7","./EllipsoidRhumbLine-281c49be","./IntersectionTests-9d9af9db","./Plane-ff99a7c3"],function(Y,Z,j,K,p,Q,X,$,ee,u,te,e,t,i,r,a,n,o,s){"use strict";var ie=new Z.Cartesian3,re=new Z.Cartesian3,ae=new Z.Cartesian3,ne=new Z.Cartesian3,oe=new Z.Cartesian3,se=new Z.Cartesian3,me=new Z.Cartesian3;function f(e){var t=(e=Y.defaultValue(e,Y.defaultValue.EMPTY_OBJECT)).positions,i=e.maximumHeights,r=e.minimumHeights;if(!Y.defined(t))throw new p.DeveloperError("options.positions is required.");if(Y.defined(i)&&i.length!==t.length)throw new p.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(Y.defined(r)&&r.length!==t.length)throw new p.DeveloperError("options.positions and options.minimumHeights must have the same length.");var a=Y.defaultValue(e.vertexFormat,u.VertexFormat.DEFAULT),n=Y.defaultValue(e.granularity,ee.CesiumMath.RADIANS_PER_DEGREE),o=Y.defaultValue(e.ellipsoid,Z.Ellipsoid.WGS84);this._positions=t,this._minimumHeights=r,this._maximumHeights=i,this._vertexFormat=u.VertexFormat.clone(a),this._granularity=n,this._ellipsoid=Z.Ellipsoid.clone(o),this._workerName="createWallGeometry";var s=1+t.length*Z.Cartesian3.packedLength+2;Y.defined(r)&&(s+=r.length),Y.defined(i)&&(s+=i.length),this.packedLength=s+Z.Ellipsoid.packedLength+u.VertexFormat.packedLength+1}f.pack=function(e,t,i){if(!Y.defined(e))throw new p.DeveloperError("value is required");if(!Y.defined(t))throw new p.DeveloperError("array is required");var r;i=Y.defaultValue(i,0);var a=e._positions,n=a.length;for(t[i++]=n,r=0;r<n;++r,i+=Z.Cartesian3.packedLength)Z.Cartesian3.pack(a[r],t,i);var o=e._minimumHeights;if(n=Y.defined(o)?o.length:0,t[i++]=n,Y.defined(o))for(r=0;r<n;++r)t[i++]=o[r];var s=e._maximumHeights;if(n=Y.defined(s)?s.length:0,t[i++]=n,Y.defined(s))for(r=0;r<n;++r)t[i++]=s[r];return Z.Ellipsoid.pack(e._ellipsoid,t,i),i+=Z.Ellipsoid.packedLength,u.VertexFormat.pack(e._vertexFormat,t,i),t[i+=u.VertexFormat.packedLength]=e._granularity,t};var c=Z.Ellipsoid.clone(Z.Ellipsoid.UNIT_SPHERE),h=new u.VertexFormat,g={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:c,vertexFormat:h,granularity:void 0};return f.unpack=function(e,t,i){if(!Y.defined(e))throw new p.DeveloperError("array is required");var r;t=Y.defaultValue(t,0);var a,n,o=e[t++],s=new Array(o);for(r=0;r<o;++r,t+=Z.Cartesian3.packedLength)s[r]=Z.Cartesian3.unpack(e,t);if(0<(o=e[t++]))for(a=new Array(o),r=0;r<o;++r)a[r]=e[t++];if(0<(o=e[t++]))for(n=new Array(o),r=0;r<o;++r)n[r]=e[t++];var m=Z.Ellipsoid.unpack(e,t,c);t+=Z.Ellipsoid.packedLength;var l=u.VertexFormat.unpack(e,t,h),d=e[t+=u.VertexFormat.packedLength];return Y.defined(i)?(i._positions=s,i._minimumHeights=a,i._maximumHeights=n,i._ellipsoid=Z.Ellipsoid.clone(m,i._ellipsoid),i._vertexFormat=u.VertexFormat.clone(l,i._vertexFormat),i._granularity=d,i):(g.positions=s,g.minimumHeights=a,g.maximumHeights=n,g.granularity=d,new f(g))},f.fromConstantHeights=function(e){var t,i,r=(e=Y.defaultValue(e,Y.defaultValue.EMPTY_OBJECT)).positions;if(!Y.defined(r))throw new p.DeveloperError("options.positions is required.");var a=e.minimumHeight,n=e.maximumHeight,o=Y.defined(a),s=Y.defined(n);if(o||s){var m=r.length;t=o?new Array(m):void 0,i=s?new Array(m):void 0;for(var l=0;l<m;++l)o&&(t[l]=a),s&&(i[l]=n)}return new f({positions:r,maximumHeights:i,minimumHeights:t,ellipsoid:e.ellipsoid,vertexFormat:e.vertexFormat})},f.createGeometry=function(e){var t=e._positions,i=e._minimumHeights,r=e._maximumHeights,a=e._vertexFormat,n=e._granularity,o=e._ellipsoid,s=te.WallGeometryLibrary.computePositions(o,t,r,i,n,!0);if(Y.defined(s)){var m,l=s.bottomPositions,d=s.topPositions,p=s.numCorners,u=d.length,f=2*u,c=a.position?new Float64Array(f):void 0,h=a.normal?new Float32Array(f):void 0,g=a.tangent?new Float32Array(f):void 0,y=a.bitangent?new Float32Array(f):void 0,v=a.st?new Float32Array(f/3*2):void 0,C=0,b=0,w=0,x=0,E=0,A=me,_=se,F=oe,D=!0,L=0,H=1/((u/=3)-p-1);for(m=0;m<u;++m){var k=3*m,V=Z.Cartesian3.fromArray(d,k,ie),G=Z.Cartesian3.fromArray(l,k,re);if(a.position&&(c[C++]=G.x,c[C++]=G.y,c[C++]=G.z,c[C++]=V.x,c[C++]=V.y,c[C++]=V.z),a.st&&(v[E++]=L,v[E++]=0,v[E++]=L,v[E++]=1),a.normal||a.tangent||a.bitangent){var P=Z.Cartesian3.clone(Z.Cartesian3.ZERO,ne),T=Z.Cartesian3.subtract(V,o.geodeticSurfaceNormal(V,re),re);if(m+1<u&&(P=Z.Cartesian3.fromArray(d,k+3,ne)),D){var z=Z.Cartesian3.subtract(P,V,ae),O=Z.Cartesian3.subtract(T,V,ie);A=Z.Cartesian3.normalize(Z.Cartesian3.cross(O,z,A),A),D=!1}Z.Cartesian3.equalsEpsilon(V,P,ee.CesiumMath.EPSILON10)?D=!0:(L+=H,a.tangent&&(_=Z.Cartesian3.normalize(Z.Cartesian3.subtract(P,V,_),_)),a.bitangent&&(F=Z.Cartesian3.normalize(Z.Cartesian3.cross(A,_,F),F))),a.normal&&(h[b++]=A.x,h[b++]=A.y,h[b++]=A.z,h[b++]=A.x,h[b++]=A.y,h[b++]=A.z),a.tangent&&(g[x++]=_.x,g[x++]=_.y,g[x++]=_.z,g[x++]=_.x,g[x++]=_.y,g[x++]=_.z),a.bitangent&&(y[w++]=F.x,y[w++]=F.y,y[w++]=F.z,y[w++]=F.x,y[w++]=F.y,y[w++]=F.z)}}var R=new X.GeometryAttributes;a.position&&(R.position=new Q.GeometryAttribute({componentDatatype:K.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})),a.normal&&(R.normal=new Q.GeometryAttribute({componentDatatype:K.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h})),a.tangent&&(R.tangent=new Q.GeometryAttribute({componentDatatype:K.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g})),a.bitangent&&(R.bitangent=new Q.GeometryAttribute({componentDatatype:K.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y})),a.st&&(R.st=new Q.GeometryAttribute({componentDatatype:K.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:v}));var S=f/3;f-=6*(p+1);var I=$.IndexDatatype.createTypedArray(S,f),q=0;for(m=0;m<S-2;m+=2){var N=m,M=m+2,W=Z.Cartesian3.fromArray(c,3*N,ie),B=Z.Cartesian3.fromArray(c,3*M,re);if(!Z.Cartesian3.equalsEpsilon(W,B,ee.CesiumMath.EPSILON10)){var U=m+1,J=m+3;I[q++]=U,I[q++]=N,I[q++]=J,I[q++]=J,I[q++]=N,I[q++]=M}}return new Q.Geometry({attributes:R,indices:I,primitiveType:Q.PrimitiveType.TRIANGLES,boundingSphere:new j.BoundingSphere.fromVertices(c)})}},function(e,t){return Y.defined(t)&&(e=f.unpack(e,t)),e._ellipsoid=Z.Ellipsoid.clone(e._ellipsoid),f.createGeometry(e)}});
//# sourceMappingURL=createWallGeometry.js.map
