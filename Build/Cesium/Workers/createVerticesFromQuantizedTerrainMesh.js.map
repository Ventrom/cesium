{"version":3,"file":"createVerticesFromQuantizedTerrainMesh.js","sources":["../../../../Source/Core/TerrainProvider.js","../../../../Source/WorkersES6/createVerticesFromQuantizedTerrainMesh.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain. This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\nvar regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {Number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  var indices = byWidth[height];\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array(\n        (width - 1) * (height - 1) * 6\n      );\n    } else {\n      indices = byWidth[height] = new Uint32Array(\n        (width - 1) * (height - 1) * 6\n      );\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nvar regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    var indices = TerrainProvider.getRegularGridIndices(width, height);\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nvar regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\n  width,\n  height\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    var gridVertexCount = width * height;\n    var gridIndexCount = (width - 1) * (height - 1) * 6;\n    var edgeVertexCount = width * 2 + height * 2;\n    var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    var vertexCount = gridVertexCount + edgeVertexCount;\n    var indexCount = gridIndexCount + edgeIndexCount;\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    var indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n      gridVertexCount,\n      indices,\n      gridIndexCount\n    );\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\n/**\n * @private\n */\nTerrainProvider.addSkirtIndices = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset\n) {\n  var vertexIndex = vertexCount;\n  offset = addSkirtIndices(\n    westIndicesSouthToNorth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(\n    southIndicesEastToWest,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(\n    eastIndicesNorthToSouth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\nfunction getEdgeIndices(width, height) {\n  var westIndicesSouthToNorth = new Array(height);\n  var southIndicesEastToWest = new Array(width);\n  var eastIndicesNorthToSouth = new Array(height);\n  var northIndicesWestToEast = new Array(width);\n\n  var i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  var index = 0;\n  for (var j = 0; j < height - 1; ++j) {\n    for (var i = 0; i < width - 1; ++i) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n\n      ++index;\n    }\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  var previousIndex = edgeIndices[0];\n\n  var length = edgeIndices.length;\n  for (var i = 1; i < length; ++i) {\n    var index = edgeIndices[i];\n\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {Number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {Number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\n  ellipsoid,\n  tileImageWidth,\n  numberOfTilesAtLevelZero\n) {\n  return (\n    (ellipsoid.maximumRadius *\n      2 *\n      Math.PI *\n      TerrainProvider.heightmapTerrainQuality) /\n    (tileImageWidth * numberOfTilesAtLevelZero)\n  );\n};\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\n * called before {@link TerrainProvider#ready} returns true.\n * @function\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability =\n  DeveloperError.throwInstantiationError;\nexport default TerrainProvider;\n","import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar maxShort = 32767;\n\nvar cartesian3Scratch = new Cartesian3();\nvar scratchMinimum = new Cartesian3();\nvar scratchMaximum = new Cartesian3();\nvar cartographicScratch = new Cartographic();\nvar toPack = new Cartesian2();\nvar scratchNormal = new Cartesian3();\nvar scratchToENU = new Matrix4();\nvar scratchFromENU = new Matrix4();\n\nfunction createVerticesFromQuantizedTerrainMesh(\n  parameters,\n  transferableObjects\n) {\n  var quantizedVertices = parameters.quantizedVertices;\n  var quantizedVertexCount = quantizedVertices.length / 3;\n  var octEncodedNormals = parameters.octEncodedNormals;\n  var edgeVertexCount =\n    parameters.westIndices.length +\n    parameters.eastIndices.length +\n    parameters.southIndices.length +\n    parameters.northIndices.length;\n  var includeWebMercatorT = parameters.includeWebMercatorT;\n\n  var rectangle = Rectangle.clone(parameters.rectangle);\n  var west = rectangle.west;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var north = rectangle.north;\n\n  var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\n\n  var exaggeration = parameters.exaggeration;\n  var minimumHeight = parameters.minimumHeight * exaggeration;\n  var maximumHeight = parameters.maximumHeight * exaggeration;\n\n  var center = parameters.relativeToCenter;\n  var fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid);\n  var toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      south\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(north) -\n        southMercatorY);\n  }\n\n  var uBuffer = quantizedVertices.subarray(0, quantizedVertexCount);\n  var vBuffer = quantizedVertices.subarray(\n    quantizedVertexCount,\n    2 * quantizedVertexCount\n  );\n  var heightBuffer = quantizedVertices.subarray(\n    quantizedVertexCount * 2,\n    3 * quantizedVertexCount\n  );\n  var hasVertexNormals = defined(octEncodedNormals);\n\n  var uvs = new Array(quantizedVertexCount);\n  var heights = new Array(quantizedVertexCount);\n  var positions = new Array(quantizedVertexCount);\n  var webMercatorTs = includeWebMercatorT\n    ? new Array(quantizedVertexCount)\n    : [];\n\n  var minimum = scratchMinimum;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  var maximum = scratchMaximum;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  var minLongitude = Number.POSITIVE_INFINITY;\n  var maxLongitude = Number.NEGATIVE_INFINITY;\n  var minLatitude = Number.POSITIVE_INFINITY;\n  var maxLatitude = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < quantizedVertexCount; ++i) {\n    var rawU = uBuffer[i];\n    var rawV = vBuffer[i];\n\n    var u = rawU / maxShort;\n    var v = rawV / maxShort;\n    var height = CesiumMath.lerp(\n      minimumHeight,\n      maximumHeight,\n      heightBuffer[i] / maxShort\n    );\n\n    cartographicScratch.longitude = CesiumMath.lerp(west, east, u);\n    cartographicScratch.latitude = CesiumMath.lerp(south, north, v);\n    cartographicScratch.height = height;\n\n    minLongitude = Math.min(cartographicScratch.longitude, minLongitude);\n    maxLongitude = Math.max(cartographicScratch.longitude, maxLongitude);\n    minLatitude = Math.min(cartographicScratch.latitude, minLatitude);\n    maxLatitude = Math.max(cartographicScratch.latitude, maxLatitude);\n\n    var position = ellipsoid.cartographicToCartesian(cartographicScratch);\n\n    uvs[i] = new Cartesian2(u, v);\n    heights[i] = height;\n    positions[i] = position;\n\n    if (includeWebMercatorT) {\n      webMercatorTs[i] =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n          cartographicScratch.latitude\n        ) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n\n    Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n    Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n  }\n\n  var westIndicesSouthToNorth = copyAndSort(parameters.westIndices, function (\n    a,\n    b\n  ) {\n    return uvs[a].y - uvs[b].y;\n  });\n  var eastIndicesNorthToSouth = copyAndSort(parameters.eastIndices, function (\n    a,\n    b\n  ) {\n    return uvs[b].y - uvs[a].y;\n  });\n  var southIndicesEastToWest = copyAndSort(parameters.southIndices, function (\n    a,\n    b\n  ) {\n    return uvs[b].x - uvs[a].x;\n  });\n  var northIndicesWestToEast = copyAndSort(parameters.northIndices, function (\n    a,\n    b\n  ) {\n    return uvs[a].x - uvs[b].x;\n  });\n\n  var orientedBoundingBox;\n  var boundingSphere;\n\n  if (exaggeration !== 1.0) {\n    // Bounding volumes need to be recomputed since the tile payload assumes no exaggeration.\n    boundingSphere = BoundingSphere.fromPoints(positions);\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid\n    );\n  }\n\n  var occludeePointInScaledSpace;\n  if (exaggeration !== 1.0 || minimumHeight < 0.0) {\n    // Horizon culling point needs to be recomputed since the tile payload assumes no exaggeration.\n    var occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n      center,\n      positions,\n      minimumHeight\n    );\n  }\n\n  var hMin = minimumHeight;\n  hMin = Math.min(\n    hMin,\n    findMinMaxSkirts(\n      parameters.westIndices,\n      parameters.westSkirtHeight,\n      heights,\n      uvs,\n      rectangle,\n      ellipsoid,\n      toENU,\n      minimum,\n      maximum\n    )\n  );\n  hMin = Math.min(\n    hMin,\n    findMinMaxSkirts(\n      parameters.southIndices,\n      parameters.southSkirtHeight,\n      heights,\n      uvs,\n      rectangle,\n      ellipsoid,\n      toENU,\n      minimum,\n      maximum\n    )\n  );\n  hMin = Math.min(\n    hMin,\n    findMinMaxSkirts(\n      parameters.eastIndices,\n      parameters.eastSkirtHeight,\n      heights,\n      uvs,\n      rectangle,\n      ellipsoid,\n      toENU,\n      minimum,\n      maximum\n    )\n  );\n  hMin = Math.min(\n    hMin,\n    findMinMaxSkirts(\n      parameters.northIndices,\n      parameters.northSkirtHeight,\n      heights,\n      uvs,\n      rectangle,\n      ellipsoid,\n      toENU,\n      minimum,\n      maximum\n    )\n  );\n\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, center);\n  var encoding = new TerrainEncoding(\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    hasVertexNormals,\n    includeWebMercatorT\n  );\n  var vertexStride = encoding.getStride();\n  var size =\n    quantizedVertexCount * vertexStride + edgeVertexCount * vertexStride;\n  var vertexBuffer = new Float32Array(size);\n\n  var bufferIndex = 0;\n  for (var j = 0; j < quantizedVertexCount; ++j) {\n    if (hasVertexNormals) {\n      var n = j * 2.0;\n      toPack.x = octEncodedNormals[n];\n      toPack.y = octEncodedNormals[n + 1];\n\n      if (exaggeration !== 1.0) {\n        var normal = AttributeCompression.octDecode(\n          toPack.x,\n          toPack.y,\n          scratchNormal\n        );\n        var fromENUNormal = Transforms.eastNorthUpToFixedFrame(\n          positions[j],\n          ellipsoid,\n          scratchFromENU\n        );\n        var toENUNormal = Matrix4.inverseTransformation(\n          fromENUNormal,\n          scratchToENU\n        );\n\n        Matrix4.multiplyByPointAsVector(toENUNormal, normal, normal);\n        normal.z *= exaggeration;\n        Cartesian3.normalize(normal, normal);\n\n        Matrix4.multiplyByPointAsVector(fromENUNormal, normal, normal);\n        Cartesian3.normalize(normal, normal);\n\n        AttributeCompression.octEncode(normal, toPack);\n      }\n    }\n\n    bufferIndex = encoding.encode(\n      vertexBuffer,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      toPack,\n      webMercatorTs[j]\n    );\n  }\n\n  var edgeTriangleCount = Math.max(0, (edgeVertexCount - 4) * 2);\n  var indexBufferLength = parameters.indices.length + edgeTriangleCount * 3;\n  var indexBuffer = IndexDatatype.createTypedArray(\n    quantizedVertexCount + edgeVertexCount,\n    indexBufferLength\n  );\n  indexBuffer.set(parameters.indices, 0);\n\n  var percentage = 0.0001;\n  var lonOffset = (maxLongitude - minLongitude) * percentage;\n  var latOffset = (maxLatitude - minLatitude) * percentage;\n  var westLongitudeOffset = -lonOffset;\n  var westLatitudeOffset = 0.0;\n  var eastLongitudeOffset = lonOffset;\n  var eastLatitudeOffset = 0.0;\n  var northLongitudeOffset = 0.0;\n  var northLatitudeOffset = latOffset;\n  var southLongitudeOffset = 0.0;\n  var southLatitudeOffset = -latOffset;\n\n  // Add skirts.\n  var vertexBufferIndex = quantizedVertexCount * vertexStride;\n  addSkirt(\n    vertexBuffer,\n    vertexBufferIndex,\n    westIndicesSouthToNorth,\n    encoding,\n    heights,\n    uvs,\n    octEncodedNormals,\n    ellipsoid,\n    rectangle,\n    parameters.westSkirtHeight,\n    exaggeration,\n    southMercatorY,\n    oneOverMercatorHeight,\n    westLongitudeOffset,\n    westLatitudeOffset\n  );\n  vertexBufferIndex += parameters.westIndices.length * vertexStride;\n  addSkirt(\n    vertexBuffer,\n    vertexBufferIndex,\n    southIndicesEastToWest,\n    encoding,\n    heights,\n    uvs,\n    octEncodedNormals,\n    ellipsoid,\n    rectangle,\n    parameters.southSkirtHeight,\n    exaggeration,\n    southMercatorY,\n    oneOverMercatorHeight,\n    southLongitudeOffset,\n    southLatitudeOffset\n  );\n  vertexBufferIndex += parameters.southIndices.length * vertexStride;\n  addSkirt(\n    vertexBuffer,\n    vertexBufferIndex,\n    eastIndicesNorthToSouth,\n    encoding,\n    heights,\n    uvs,\n    octEncodedNormals,\n    ellipsoid,\n    rectangle,\n    parameters.eastSkirtHeight,\n    exaggeration,\n    southMercatorY,\n    oneOverMercatorHeight,\n    eastLongitudeOffset,\n    eastLatitudeOffset\n  );\n  vertexBufferIndex += parameters.eastIndices.length * vertexStride;\n  addSkirt(\n    vertexBuffer,\n    vertexBufferIndex,\n    northIndicesWestToEast,\n    encoding,\n    heights,\n    uvs,\n    octEncodedNormals,\n    ellipsoid,\n    rectangle,\n    parameters.northSkirtHeight,\n    exaggeration,\n    southMercatorY,\n    oneOverMercatorHeight,\n    northLongitudeOffset,\n    northLatitudeOffset\n  );\n\n  TerrainProvider.addSkirtIndices(\n    westIndicesSouthToNorth,\n    southIndicesEastToWest,\n    eastIndicesNorthToSouth,\n    northIndicesWestToEast,\n    quantizedVertexCount,\n    indexBuffer,\n    parameters.indices.length\n  );\n\n  transferableObjects.push(vertexBuffer.buffer, indexBuffer.buffer);\n\n  return {\n    vertices: vertexBuffer.buffer,\n    indices: indexBuffer.buffer,\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n    vertexStride: vertexStride,\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n    encoding: encoding,\n    indexCountWithoutSkirts: parameters.indices.length,\n  };\n}\n\nfunction findMinMaxSkirts(\n  edgeIndices,\n  edgeHeight,\n  heights,\n  uvs,\n  rectangle,\n  ellipsoid,\n  toENU,\n  minimum,\n  maximum\n) {\n  var hMin = Number.POSITIVE_INFINITY;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var length = edgeIndices.length;\n  for (var i = 0; i < length; ++i) {\n    var index = edgeIndices[i];\n    var h = heights[index];\n    var uv = uvs[index];\n\n    cartographicScratch.longitude = CesiumMath.lerp(west, east, uv.x);\n    cartographicScratch.latitude = CesiumMath.lerp(south, north, uv.y);\n    cartographicScratch.height = h - edgeHeight;\n\n    var position = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      cartesian3Scratch\n    );\n    Matrix4.multiplyByPoint(toENU, position, position);\n\n    Cartesian3.minimumByComponent(position, minimum, minimum);\n    Cartesian3.maximumByComponent(position, maximum, maximum);\n\n    hMin = Math.min(hMin, cartographicScratch.height);\n  }\n  return hMin;\n}\n\nfunction addSkirt(\n  vertexBuffer,\n  vertexBufferIndex,\n  edgeVertices,\n  encoding,\n  heights,\n  uvs,\n  octEncodedNormals,\n  ellipsoid,\n  rectangle,\n  skirtLength,\n  exaggeration,\n  southMercatorY,\n  oneOverMercatorHeight,\n  longitudeOffset,\n  latitudeOffset\n) {\n  var hasVertexNormals = defined(octEncodedNormals);\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var length = edgeVertices.length;\n  for (var i = 0; i < length; ++i) {\n    var index = edgeVertices[i];\n    var h = heights[index];\n    var uv = uvs[index];\n\n    cartographicScratch.longitude =\n      CesiumMath.lerp(west, east, uv.x) + longitudeOffset;\n    cartographicScratch.latitude =\n      CesiumMath.lerp(south, north, uv.y) + latitudeOffset;\n    cartographicScratch.height = h - skirtLength;\n\n    var position = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      cartesian3Scratch\n    );\n\n    if (hasVertexNormals) {\n      var n = index * 2.0;\n      toPack.x = octEncodedNormals[n];\n      toPack.y = octEncodedNormals[n + 1];\n\n      if (exaggeration !== 1.0) {\n        var normal = AttributeCompression.octDecode(\n          toPack.x,\n          toPack.y,\n          scratchNormal\n        );\n        var fromENUNormal = Transforms.eastNorthUpToFixedFrame(\n          cartesian3Scratch,\n          ellipsoid,\n          scratchFromENU\n        );\n        var toENUNormal = Matrix4.inverseTransformation(\n          fromENUNormal,\n          scratchToENU\n        );\n\n        Matrix4.multiplyByPointAsVector(toENUNormal, normal, normal);\n        normal.z *= exaggeration;\n        Cartesian3.normalize(normal, normal);\n\n        Matrix4.multiplyByPointAsVector(fromENUNormal, normal, normal);\n        Cartesian3.normalize(normal, normal);\n\n        AttributeCompression.octEncode(normal, toPack);\n      }\n    }\n\n    var webMercatorT;\n    if (encoding.hasWebMercatorT) {\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n          cartographicScratch.latitude\n        ) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    vertexBufferIndex = encoding.encode(\n      vertexBuffer,\n      vertexBufferIndex,\n      position,\n      uv,\n      cartographicScratch.height,\n      toPack,\n      webMercatorT\n    );\n  }\n}\n\nfunction copyAndSort(typedArray, comparator) {\n  var copy;\n  if (typeof typedArray.slice === \"function\") {\n    copy = typedArray.slice();\n    if (typeof copy.sort !== \"function\") {\n      // Sliced typed array isn't sortable, so we can't use it.\n      copy = undefined;\n    }\n  }\n\n  if (!defined(copy)) {\n    copy = Array.prototype.slice.call(typedArray);\n  }\n\n  copy.sort(comparator);\n\n  return copy;\n}\nexport default createTaskProcessorWorker(\n  createVerticesFromQuantizedTerrainMesh\n);\n"],"names":["TerrainProvider","DeveloperError","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","ready","readyPromise","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","CesiumMath","FOUR_GIGABYTES","byWidth","defined","indices","addRegularGridIndices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","i","Array","offset","index","j","upperLeft","lowerLeft","lowerRight","upperRight","addSkirtIndices","vertexIndex","previousIndex","length","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","vertexCount","indexCount","Math","max","IndexDatatype","createTypedArray","indexCountWithoutSkirts","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","maxShort","cartesian3Scratch","Cartesian3","scratchMinimum","scratchMaximum","cartographicScratch","Cartographic","toPack","Cartesian2","scratchNormal","scratchToENU","Matrix4","scratchFromENU","findMinMaxSkirts","edgeHeight","heights","uvs","rectangle","toENU","minimum","maximum","hMin","Number","POSITIVE_INFINITY","north","south","east","west","TWO_PI","h","uv","longitude","lerp","x","latitude","y","position","cartographicToCartesian","multiplyByPoint","minimumByComponent","maximumByComponent","min","addSkirt","vertexBuffer","vertexBufferIndex","edgeVertices","encoding","octEncodedNormals","skirtLength","exaggeration","southMercatorY","oneOverMercatorHeight","longitudeOffset","latitudeOffset","webMercatorT","n","normal","AttributeCompression","octDecode","fromENUNormal","Transforms","eastNorthUpToFixedFrame","toENUNormal","inverseTransformation","multiplyByPointAsVector","z","normalize","octEncode","hasWebMercatorT","WebMercatorProjection","geodeticLatitudeToMercatorAngle","encode","copyAndSort","typedArray","comparator","copy","slice","sort","undefined","call","createTaskProcessorWorker","parameters","transferableObjects","quantizedVertices","quantizedVertexCount","westIndices","eastIndices","southIndices","northIndices","includeWebMercatorT","Rectangle","clone","Ellipsoid","minimumHeight","maximumHeight","center","relativeToCenter","fromENU","uBuffer","subarray","vBuffer","heightBuffer","positions","webMercatorTs","NEGATIVE_INFINITY","minLongitude","maxLongitude","minLatitude","maxLatitude","rawU","rawV","u","v","orientedBoundingBox","boundingSphere","occludeePointInScaledSpace","a","b","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","aaBox","AxisAlignedBoundingBox","TerrainEncoding","vertexStride","getStride","Float32Array","bufferIndex","edgeTriangleCount","indexBufferLength","indexBuffer","set","lonOffset","latOffset","westLongitudeOffset","eastLongitudeOffset","northLatitudeOffset","southLatitudeOffset","push","buffer","vertices"],"mappings":"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"}